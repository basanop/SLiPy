{"name":"Slipy","tagline":"A Spectroscopy and astrophysical Library for Python 3","body":"# [SLiPy](http://glentner.github.io/SLiPy)\r\n\r\n#### A Spectroscopy and astrophysical Library for Python 3\r\n\r\nThis Python package is an expanding code base for doing computational\r\nastronomy, particularly spectroscopy. It contains both a *Spectrum* class\r\nfor handling spectra as objects (with +, -, \\*, /, etc... operations defined)\r\nand a growing suite of analysis tools.\r\n\r\n**Dependencies:**\r\nPython 3.x,\r\n[astropy](http://www.astropy.org),\r\n[matplotlib](http://matplotlib.org),\r\n[numpy](http://www.numpy.org),\r\n[scipy](http://www.scipy.org)\r\n\r\n[![astropy](http://img.shields.io/badge/powered%20by-AstroPy-orange.svg?style=flat)](http://www.astropy.org/)\r\n[![GitHub license](https://img.shields.io/badge/license-GPLv3-blue.svg)](http://www.gnu.org/copyleft/gpl.html)\r\n\r\nQuick note: the subpackage **astrolibpy** was not developed\r\nby me. It was coded by Sergey Koposov (@segasai) at Cambridge (then at least).\r\nI found it useful for performing velocity corrections on my spectroscopic\r\ndata. I've modified several modules such that it can be imported and used in\r\nPython 3.x. See his README file.\r\n\r\n## Contents\r\n\r\nSLiPy is split into several components. The principle component is the\r\nsubpackage **SLiPy** itself, which contains all the relevant\r\nfunctionality. Further, **Data** is a package I'm working on that will provide\r\nan API for searching astronomical data archives in a simple way. The other two\r\nsubpackages **Framework** and **astrolibpy** are of utility to the project but\r\nnot necessarily intended for export. As stated previously, astrolibpy was not\r\ndeveloped by me, only modified. I'm not going to document it's usage here. Its\r\nname is unfortunate for me as it is a bit over done with the convention I was\r\nalready using, but for consistency I will keep it as it was from the author.\r\n\r\nThe following modules are elevated to the package level and are available\r\nto import:\r\n\r\n| Module | Functions/Classes |\r\n|--------|-------------------|\r\n|[**Fits**](#FitsLoc)|[Find](#FindLoc), [RFind](#RFindLoc), [GetData](#GetDataLoc), [Header](#HeaderLoc), [Search](#SearchLoc), [PositionSort](#PositionSortLoc), |\r\n|[**DataType**](#DataTypeLoc)|[WaveVector](#WaveVectorLoc), [Spectrum](#SpectrumLoc), |\r\n|[**Simbad**](#SimbadLoc)|[Query](#QueryLoc), [Position](#PositionLoc), [Distance](#DistanceLoc), [Sptype](#SptypeLoc), [IDList](#IDListLoc), |\r\n|[**Correlate**](#CorrelateLoc)|[XCorr](#XCorrLoc), |\r\n|[**Telluric**](#TelluricLoc)|[Correct](#CorrectLoc), |\r\n|[**Velocity**](#VelocityLoc)|[HelioCorrect](#HelioCorrectLoc), |\r\n|[**Observatory**](#ObservatoryLoc)|[OHP](#OHPLoc), |\r\n|[**Plot**](#PlotLoc)|[SPlot](#SPlotLoc), [Iterate](#IterateLoc), |\r\n|[Montage](#MontageLoc)|[Mosaic](#MosaicLoc), [SubField](#SubFieldLoc), [Field](#FieldLoc), |\r\n|[Elodie](#ElodieLoc)|[Archive](#ArchiveLoc), [Script](#ScriptLoc), [Download](#DownloadLoc), |\r\n\r\n##Installation\r\n\r\nTo install SLiPy, there is no setup procedure. Simply download the package,\r\neither by clicking on the download link for a *tar* or *zip* archive or by\r\ncloning it (`git clone http://github.com/glentner/SLiPy`). Extract it's\r\ncontents to wherever you like in a directory (ostensibly names *slipy*, but\r\nactually you can call this library whatever you want as well because all\r\nthe imports are *relative*). Then add the parent directory to your `PYTHONPATH`\r\nif it isn't already. For example:\r\n\r\n```sh\r\ncd\r\ngit clone http://github.com/glentner/SLiPy\r\necho \"export PYTHONPATH=$PYTHONPATH:/~\" >> ~/.bashrc\r\n```\r\n\r\nAnd your ready to go!\r\n\r\n##Contribute\r\n\r\nIf you use SLiPy or have your own code related to spectroscopy or computing\r\nfor astronomy and think it would be a useful addition (or you find a\r\nbug/mistake) I'm more than open to suggested contributions/additions.\r\n\r\n##Author\r\n\r\nGeoffrey Lentner, B.S.  \r\nGraduate Research Assistant  \r\nDepartment of Physics & Astronomy  \r\nUniversity of Louisville\r\n\r\nW: [glentner.github.io](http://glentner.github.io)\r\nE: [grlent01@louisville.edu](mailto:grlent01@louisville.edu)\r\n\r\n---\r\n\r\n#<a name=FitsLoc></a>[Fits](SLiPy/Fits.py)\r\n\r\nManipulate FITS files. Import data into *Spectrum* objects. Filter results\r\nby right ascension and declination. Grab header elements. Search for attributes\r\nof the data such as distance, spectral type, etc.\r\n\r\n<a name=FindLoc></a>\r\n- **Find** (*toplevel* = './', *pattern* = '\\*.fits'):\r\n\r\n    Search for file paths below *toplevel* fitting *pattern*. Returns a list\r\n    of string values.\r\n\r\n<a name=RFindLoc></a>\r\n- **RFind** (*toplevel* = './', *pattern* = '\\*.fits'):\r\n\r\n    Recursively search for file paths below *toplevel* fitting *pattern*.\r\n    Returns a list of string values.\r\n\r\n<a name=GetDataLoc></a>\r\n- **GetData** ( \\**files*, \\*\\**kwargs*):\r\n\r\n\tImport data from FITS `files`. Returns a list of *Spectrum* objects.\r\n\r\n    |Options     | Defaults        | Descriptions\r\n    |------------|-----------------|------------------------------------------|\r\n    |*verbose*   | True            | display messages, progress               |\r\n    |*toplevel*  | ''              | request import from directory *toplevel* |  \r\n    |*pattern*   | '\\*.fits'       | pattern matching with *toplevel*         |\r\n    |*recursive* | False           | search recursively below *toplevel*      |\r\n    |*wavecal*   | True            | fit wavelength vector to data            |\r\n    |*crpix1*    | 'crpix1'        | reference pixel header keyword           |\r\n    |*crval1*    | 'crval1'        | value at reference pixel                 |\r\n    |*cdelt1*    | 'cdelt1'        | resolution (delta lambda)                |\r\n    |*xunits*    | 'Angstrom'      | wavelength units (astropy.units)         |\r\n    |*yunits*    | 'ergs cm-2 s-1' | units of the data                        |\r\n\r\n<a name=HeaderLoc></a>\r\n- **Header** ( *filename*, *keyword*, \\*\\**kwargs*):\r\n\r\n    Retrieve *keyword* from FITS header in file *filename*.\r\n    Return type depends on what is returned.\r\n\r\n<a name=SearchLoc></a>\r\n- **Search** ( \\**files*, \\*\\**kwargs*):\r\n\r\n    Extract object names from Fits *files* and use Simbad module\r\n    to resolve the *attribute* (a required keyword argument)\r\n    from the SIMBAD astronomical database. Currently available attributes\r\n    are 'Position', 'Distance', 'Sptype', and 'IDList'. Returns a list of\r\n    results (type depends on the values).\r\n\r\n    | Options     | Defaults  | Descriptions                         |\r\n    |-------------|-----------|--------------------------------------|\r\n    | *verbose*   | True      | display messages, progress           |\r\n    | *toplevel*  | None      | search under *toplevel* directory    |\r\n    | *pattern*   | '\\*.fits' | for files under *toplevel*           |\r\n    | *recursive* | False     | search recusively under *toplevel*   |\r\n    | *attribute* | None      | attribute to search for (no default) |\r\n\r\n<a name=PositionSortLoc></a>\r\n- **PositionSort** ( *center*, *radius*, \\**files*, \\*\\**kwargs* ):\r\n\r\n    Return a list of files from *files* that lie in a *radius* (in\r\n    decimal degrees) from *center*, based on the *ra* (right ascension) and\r\n    *dec* (declination).\r\n\r\n    | Options   | Defaults | Descriptions                             |\r\n    |-----------|----------|------------------------------------------|\r\n    *ra*        | 'pos1'   | header element for right ascension       |\r\n    *dec*       | 'pos2'   | header element for declination           |\r\n    *obj*       | 'object' | header element for object id             |\r\n    *raconvert* | True     | convert decimal hours to decimal degrees |\r\n    *verbose*   | True     | display messages, progress               |\r\n    *toplevel*  | None     | *toplevel* directory to look for files   |\r\n    *recursive* | False    | search *toplevel*ly below *toplevel*     |\r\n    *pattern*   |'\\*.fits' | glob *pattern* for file search           |\r\n    *useSimbad* | False    | use *Simbad* instead of header elements  |\r\n\r\n\r\n#<a name=DataTypeLoc></a>[DataType](SLiPy/DataType.py)\r\n\r\nObjects for representing astronomical data. Currently, this includes the\r\n*Spectrum* class and it's helper function *WaveVector*\r\n\r\n<a name=WaveVectorLoc></a>\r\n- **WaveVector** ( *rpix*, *rval*, *delt*, *npix* ):\r\n\r\n    Construct numpy array of wavelength values where *rpix* is the reference\r\n    pixel index, *rval* is the wavelength at reference pixel, *delt* is the\r\n    resolutions (delta lambda), and *npix* is the length of desired array.\r\n\r\n```Python\r\nclass Spectrum:\r\n\t\"\"\"\r\n\tSpectrum objects consist of a `data` vector, and optionally a  \r\n\t`wavelength` vector (accessed with .data and .wave respectively).\r\n    (+, -, *, /, +=, -=, *=, /=) are overloaded. The LHS spectrum is the\r\n    reference and the RHS spectrum is resampled onto the wavelength space\r\n    of the LHS spectrum before applying operations pixel-wise. Scalar\r\n    operations applied to all pixels.\r\n\t\"\"\"\r\n\tdef __init__(self, argument, **kwargs ):\r\n\t\t\"\"\"\r\n\t\tHold spectrum `data` from file name `argument`. Alternatively,\r\n\t\tconstruct spectra with a one-dimensional numpy.ndarray as `argument`.\r\n\t\t`wavecal` is assumed to be true for file input.\r\n\r\n\t\tkwargs = {\r\n    \t\t'wavecal': True     , # fit wavelength vector to data\r\n    \t\t'crpix1' : 'crpix1' , # reference pixel header keyword\r\n    \t\t'crval1' : 'crval1' , # value at reference pixel\r\n    \t\t'cdelt1' : 'cdelt1' , # resolution (delta lambda)\r\n\t\t}\r\n    \"\"\"\r\n```\r\n\r\n#<a name=SimbadLoc></a>Simbad\r\n\r\nThis module allows the user to query the SIMBAD astronomical database from\r\ninside Python or shell commands/scripts.\r\n\r\nAs a shell script:\r\n\r\n```\r\nusage: Simbad.py @Attribute <identifier> [**kwargs]\r\n\r\nThe 'Attribute' points to a function within this module and indicates\r\nwhat is to be run. Execute 'Simbad.py @Attribute help' for usage details of\r\na specific function. Currently available attributes are: `Position`,\r\n`Distance`, `Sptype` and `IDList`.\r\n\r\nThe identifier names can be anything recognized by SIMBAD (e.g., Regulus,\r\n\"alpha leo\", \"HD 121475\", \"del cyg\", etc ...) if the name is two parts make\r\nsure to use quotation to enclose it.\r\n\r\nThe **kwargs is the conventional reference to Python keyword arguments.\r\nThese should be specific to the 'Attribute' being pointed to.\r\n```\r\n\r\nThe following objects/functions are available:\r\n\r\n```Python\r\nclass Query:\r\n\t\"\"\"\r\n\tQuery( identifier, criteria, **kwargs ):\r\n\r\n\tClass for querying the SIMBAD astronomical database for 'citeria'\r\n\tof 'identifier'. This object is not intended to be used directly; it\r\n    is an abstraction and is used by the other functions which should be\r\n    called by the user.\r\n\r\n\tkwargs = {\r\n\t\t'parse' : True,  # extract relevant data from SIMBAD return file\r\n\t\t'dtype' : float, # output datatype\r\n\t}\r\n\t\"\"\"\r\n```\r\n```Python\r\ndef Position( identifier, **kwargs ):\r\n\t\"\"\"\r\n\tPosition( identifier, **kwargs ):\r\n\r\n\tHandle to the Query class with criteria='%C00(d;C)'. Return right\r\n    ascension and declination in decimal degrees of `identifier`.\r\n\r\n    Example:\r\n\r\n    ra, dec = Position('Sirius')\r\n\t\"\"\"\r\n```\r\n```Python\r\ndef Distance( identifier, **kwargs ):\r\n\t\"\"\"\r\n\tDistance( identifier, **kwargs ):\r\n\r\n\tHandle to the Query class with criteria='%PLX' Return the distance\r\n    in parsecs to `identifier`.\r\n\r\n    Example:\r\n\r\n    d = Distance('rigel kent')\r\n\t\"\"\"\r\n```\r\n```Python\r\ndef Sptype(identifier, **kwargs):\r\n\t\"\"\"\r\n\tSptype( identifier, **kwargs ):\r\n\r\n\tHandle to the Query class with criteria='%SP'. Return the\r\n    spectral type as resolved by SIMBAD.\r\n\r\n    Example:\r\n\r\n    sptype = Sptype('HD 87901') # returns 'B8IVn' (HD 87901 is Regulus)\r\n\t\"\"\"\r\n```\r\n```Python\r\ndef IDList(identifier, **kwargs):\r\n\t\"\"\"\r\n\tIDList(identifier, **kwargs):\r\n\r\n\tHandle to the Query class with criteria='%IDLIST'.\r\n\tWith `parse` = True, return a list of alternate IDs for\r\n\tthe `identifier` provided.\r\n\r\n    Example:\r\n\r\n    other_names = IDList('proxima centauri')\r\n    \"\"\"\r\n```\r\n\r\n#<a name=CorrelateLoc></a>Correlate\r\n\r\nModule of correlation functions for astronomical data.\r\n\r\n```Python\r\ndef Xcorr( spectrumA, spectrumB, **kwargs ):\r\n\t\"\"\"\r\n\tCross correlate two spectra of equal pixel length. The function returns\r\n\tan integer value representing the best shift within a `lag` based on\r\n\tthe computed RMS of each configuration.\r\n\t\"\"\"\r\n```\r\n\r\n#<a name=TelluricLoc></a>Telluric\r\n\r\nRemoval of atmospheric adsorption lines in spectra.\r\n\r\n```Python\r\ndef Correct(spectrum, *calibration, **kwargs):\r\n\t\"\"\"\r\n\tPerform a telluric correction on `spectrum` with one or more\r\n\t`calibration` spectra. If more than one calibration spectrum is\r\n\tprovided, the one with the best fit after performing both a\r\n\thorizontal cross correlation and a vertical amplitude fit is used.\r\n\tThe spectrum and all the calibration spectra must have the same\r\n\tnumber of pixels (elements). If a horizontal shift in the calibration\r\n\tspectra is appropriate, only the corresponding range of the spectrum\r\n\tis divided out!\r\n\r\n\tkwargs = {\r\n\t\t\tlag  : 25            , # pixel shift limit for XCorr()\r\n\t\t\trange:(0.5, 2.0, 151), # numpy.linspace for amplitude trials\r\n\t\t}\r\n\t\"\"\"\r\n```\r\n\r\n<img src=\"Figures/HD192640.png\" alt=\"Results of Telluric.Correct()\">\r\n\r\n**Figure 1:** The above figure is an example of applying the\r\n**Telluric.Correct()** algorithm to a spectrum. In this case, six spectra of\r\n*Regulus* from the Elodie archive were used as calibration spectra.\r\n\r\n#<a name=VelocityLoc></a>Velocity\r\n\r\nRadial velocity corrections for 1D spectra.\r\n\r\n```Python\r\ndef HelioCorrect( obs, *spectra, **kwargs ):\r\n\t\"\"\"\r\n\tPerform heliocentric velocity corrects on `spectra` based on\r\n\t`obs`ervatory information (longitude, latitude, altitude) and the\r\n\tmember attributes, ra (right ascension), dec (declination), and jd\r\n\t(julian date) from the `spectra`.\r\n\r\n    The `ra` and `dec` must be attached to each spectrum. `obs` should\r\n    be of type Observatory.\r\n\t\"\"\"\r\n```\r\n```Python\r\ndef IrafInput( *files, **kwargs):\r\n\t\"\"\"\r\n\tBuild an input file for IRAF's rvcorrect task.\r\n\r\n\t`files` should be a list of FITS file names to build the output table for.\r\n\tThe user can optionally specify a `toplevel` directory to search for files\r\n    under. If `outfile` is given, write results to the file.\r\n\r\n\tkwargs = {\r\n\t\t'toplevel' : ''      , # search `toplevel` directory for files\r\n\t\t'pattern'  : '*.fits', # files under `toplevel` fitting `pattern`\r\n\t\t'recursive': False   , # search recusively under `toplevel`\r\n\t\t'outfile'  : ''        # write lines to file named `outfile`\r\n\t}\r\n\t\"\"\"\r\n```\r\n```Python\r\ndef HeaderInfo( fpath ):\r\n\t\"\"\"\r\n\tHelper function of IrafInput().\r\n\r\n\tReturn a formatted string containing the year, month, and day of\r\n\tobservation from the FITS file with name `fpath`, as well as the\r\n\tuniversal time of observation and the right ascension and declination\r\n\tof the target.\r\n\t\"\"\"\r\n```\r\n#<a name=ObservatoryLoc></a>Observatory\r\n\r\nDefine observatory parameter similar to the IRAF task. All observatories\r\nshould follow the following pattern. The user can add as many as they like\r\nto this module. I welcome suggestions.\r\n\r\n```Python\r\nclass OHP(Observatory):\r\n\t\"\"\"\r\n\tThe Observatoire de Haute-Provence, France.\r\n\t\"\"\"\r\n\tdef __init__(self):\r\n\t\tself.name      = 'Observatoire de Haute-Provence'\r\n\t\tself.latitude  = 43.9308334 # degrees N\r\n\t\tself.longitude = 356.28667  # degrees W\r\n\t\tself.altitude  = 650        # meters\r\n```\r\n\r\n#<a name=PlotLoc></a>Plot\r\n\r\nConvenience tools for plotting spectra. **SPlot** takes a Spectrum object\r\nand remains like a handle to the plot for that object. All of the typical\r\nmember commands to matplotlib.pyplot exist, but once called are *remembered*.\r\nAdditionally, spectra can be `overlay`ed. **Iterate** is a function that takes\r\nany number of SPlot figures and iterates through them interactively and lets\r\nthe user mark which ones to `keep`. The return is a list of either the names\r\nof the figures or the actually objects themselves.\r\n\r\n```Python\r\nclass SPlot:\r\n\t\"\"\"\r\n\tSpectrum Plot - Plot the data in `spectrum`.\r\n\t\"\"\"\r\n\tdef __init__(self, spectrum, **kwargs):\r\n\t\t\"\"\"\r\n\t\tAssign `options` in `kwargs` and initialize the plot.\r\n\r\n        kwargs = {\r\n\t\t\t'marker': 'b-'          , # marker for plot\r\n\t\t\t'label' : 'unspecified' , # label for data\r\n\t\t\t'usetex': False           # pdflatex setting\r\n\t\t}\r\n        \"\"\"\r\n```\r\n```Python\r\ndef Iterate( *plots, **kwargs ):\r\n\t\"\"\"\r\n\tIterate thru `plots` to inspect data, the user marks `plots` of\r\n\tinterest. The function returns a list of `names` marked.\r\n\t\"\"\"\r\n```\r\n\r\n#<a name=ElodieLoc></a>Elodie\r\n\r\nMethods for data retrieval from the Elodie Archive.\r\n\r\n```Python\r\nclass Archive:\r\n    \"\"\"\r\n    Import and parse ascii catalog of Elodie archive files. The complete\r\n    archive is stored in the member `data`. It's organized in a dictionary\r\n    by unique target names. The reduced archive of contains identified `HD`,\r\n    `BD`, `GC`, and `GJ` objects, choosing the file pertaining to the spectra\r\n    with the highest signal-to-noise ratio available.\r\n    \"\"\"\r\n```\r\n```Python\r\ndef Script(filename, pipeline=''):\r\n\t\"\"\"\r\n\tConstruct url script for Elodie archive given `filename` and optionally\r\n\t`pipeline` instructions (e.g., `&z=wrs|fca[1,nor]`).\r\n\t\"\"\"\r\n```\r\n```Python\r\ndef Download( *files, **kwargs ):\r\n    \"\"\"\r\n    Download `files` from Elodie archive via url scripts. The spectra can be\r\n    further reduced via Elodie`s pipeline with the following options.\r\n\r\n    kwargs = {\r\n            'verbose'  : True           , # display messages, progress\r\n            'resample' : (min, max, res), # resample spectra (no default)\r\n            'normalize': True           , # continuum normalization\r\n            'outpath'  : './'           , # directory for downloaded files\r\n            'names'    : []               # alternative output names for `files`\r\n        }\r\n    \"\"\"\r\n```\r\n\r\n#<a name=MontageLoc></a>Montage\r\n\r\nWrapper to the *montage* mosaic software. See\r\n[online](http://montage.ipac.caltech.edu/). The user should have Montage`s\r\nexecutables available on their path. This module automates the process of\r\nconstructing large mosaics. It is largely modeled after the examples given on\r\nthe website. More documentation will be provided in the future ...\r\n\r\n```Python\r\ndef Mosaic(resolution, *folders, **kwargs):\r\n\t\"\"\"\r\n\tMosaic(resolution, *folders, **kwargs):\r\n\r\n\tConduct standard build procedures for all `folders`. `resolution` is the\r\n\tnumber of pixels per degree for the output image. Note: `folders` should\r\n\tbe absolute paths. See the M101 example online. All `folder`s should\r\n    have subfolders \"projected\", \"corrected\", \"final\", and \"differences\"\r\n    available as well as a \"raw\" directory containing the images to be\r\n    mosaic-ed.\r\n\r\n\tkwargs = {\r\n\t\t\tverbose : True, # display messages, progress\r\n\t\t\tbkmodel : True  # model and correct for background effects\r\n\t\t}\r\n\t\"\"\"\r\n```\r\n```Python\r\ndef SolveGrid( sides, grid ):\r\n\t\"\"\"\r\n\tSolveGrid( sides, grid ):\r\n\r\n\tHelper function for the Field and SubField classes. Both `sides` and `grid`\r\n\tneed to be array-like and of length two. `sides` is the side length of the\r\n\tfield in decimal degrees in right ascension and declination respectively.\r\n\t`grid` specifies the subdivision along these axis (e.g., (2,2) says 2x2).\r\n\r\n\tThe user should mindful of their choices. If the side lengths cannot be\r\n\tsubdivided into well-behaved (rational) segments, higher decimal places\r\n\twill be lossed in the SubField.ArchiveList() task resulting in small\r\n\tgaps in the mosaic.\r\n\t\"\"\"\r\n```\r\n\r\n#<a name=DisplayLoc></a>Display\r\n\r\n\r\n```Python\r\nclass Monitor:\r\n\t\"\"\"\r\n\tClass for displaying a progress bar during iterative tasks.\r\n\t\"\"\"\r\n\tdef __init__(self, **kwargs ):\r\n        \"\"\"\r\n        kwargs = {\r\n\t\t\t'width'    : 45    , # number of characters wide\r\n\t\t\t'numbers'  : True  , # display numberical percent\r\n\t\t\t'template' : '[=>]', # template for progress bars\r\n\t\t\t'freq'     : 0.25  , # refresh rate\r\n\t\t\t'ETC'      : False , # display estimated time of completion\r\n\t\t\t'inline'   : True    # vanish after completion\r\n\t\t}\r\n        \"\"\"\r\n```\r\n","google":"UA-58405300-1","note":"Don't delete this file! It's used internally to help with page regeneration."}