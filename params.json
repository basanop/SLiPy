{"name":"Slipy","tagline":"A Spectroscopy and astrophysical Library for Python 3","body":"# [SLiPy](http://glentner.github.io/SLiPy)\r\n\r\n#### A Spectroscopy and astrophysical Library for Python 3\r\n\r\nThis Python package is an expanding code base for doing computational\r\nastronomy, particularly spectroscopy. It contains both a *Spectrum* class\r\nfor handling spectra as objects (with +, -, \\*, /, etc... operations defined)\r\nand a growing suite of analysis tools.\r\n\r\n**Dependencies:**\r\nPython 3.x,\r\n[astropy](http://www.astropy.org),\r\n[matplotlib](http://matplotlib.org),\r\n[numpy](http://www.numpy.org),\r\n[scipy](http://www.scipy.org)\r\n\r\n[![astropy](http://img.shields.io/badge/powered%20by-AstroPy-orange.svg?style=flat)](http://www.astropy.org/)\r\n[![GitHub license](https://img.shields.io/badge/license-GPLv3-blue.svg)](http://www.gnu.org/copyleft/gpl.html)\r\n\r\nQuick note: the subpackage **astrolibpy** was not developed\r\nby me. It was coded by Sergey Koposov (@segasai) at Cambridge (then at least).\r\nI found it useful for performing velocity corrections on my spectroscopic\r\ndata. I've modified several modules such that it can be imported and used in\r\nPython 3.x. See his README file.\r\n\r\n## Contents\r\n\r\nSLiPy is split into several components. The principle component is the\r\nsubpackage **SLiPy** itself, which contains all the relevant\r\nfunctionality. Further, **Data** is a package I'm working on that will provide\r\nan API for searching astronomical data archives in a simple way. The other two\r\nsubpackages **Framework** and **astrolibpy** are of utility to the project but\r\nnot necessarily intended for export. As stated previously, astrolibpy was not\r\ndeveloped by me, only modified. I'm not going to document it's usage here. Its\r\nname is unfortunate for me as it is a bit over done with the convention I was\r\nalready using, but for consistency I will keep it as it was from the author.\r\n\r\nThe following modules are elevated to the package level and are available\r\nto import:\r\n\r\n| Module | Functions/Classes |\r\n|--------|-------------------|\r\n|[**Fits**](#FitsLoc)|[Find](#FindLoc), [RFind](#RFindLoc), [GetData](#GetDataLoc), [Header](#HeaderLoc), [Search](#SearchLoc), [PositionSort](#PositionSortLoc), |\r\n|[**DataType**](#DataTypeLoc)|[WaveVector](#WaveVectorLoc), [Spectrum](#SpectrumLoc), |\r\n|[**Simbad**](#SimbadLoc)|[Position](#PositionLoc), [Distance](#DistanceLoc), [Sptype](#SptypeLoc), [IDList](#IDListLoc), |\r\n|[**Correlate**](#CorrelateLoc)|[XCorr](#XCorrLoc), |\r\n|[**Telluric**](#TelluricLoc)|[Correct](#CorrectLoc), |\r\n|[**Velocity**](#VelocityLoc)|[HelioCorrect](#HelioCorrectLoc), [BaryCorrect](#BaryCorrectLoc), [IrafInput](#IrafInputLoc),  |\r\n|[**Observatory**](#ObservatoryLoc)|[OHP](#OHPLoc), |\r\n|[**Plot**](#PlotLoc)|[SPlot](#SPlotLoc), [Iterate](#IterateLoc), |\r\n|[**Montage**](#MontageLoc)|[Mosaic](#MosaicLoc), [SubField](#SubFieldLoc), [Field](#FieldLoc), |\r\n|[**Elodie**](#ElodieLoc)|[Archive](#ArchiveLoc), [Script](#ScriptLoc), [Download](#DownloadLoc), |\r\n\r\n##Installation\r\n\r\nTo install SLiPy, there is no setup procedure. Simply download the package,\r\neither by clicking on the download link for a *tar* or *zip* archive or by\r\ncloning it - `git clone http://github.com/glentner/SLiPy`. Extract it's\r\ncontents to wherever you like in a directory (ostensibly named *slipy*, but\r\nactually you can call this library whatever you want as well because all\r\nthe imports are *relative*). Then add the parent directory to your `PYTHONPATH`\r\nif it isn't already. For example:\r\n\r\n```\r\n$ cd\r\n$ git clone http://github.com/glentner/SLiPy\r\n$ echo \"export PYTHONPATH=$PYTHONPATH:~\" >> ~/.bashrc\r\n```\r\n\r\nAnd your ready to go!\r\n\r\n##Exceptions\r\n\r\nSLiPy attempts to catch all foreseeable exceptions and re-throw them under a\r\ncommon handle with a human readable message. There is a unique exception class\r\nfor every module derived from `Exception`. The naming convention is for a\r\nmodule's exception to be named after the module with the addition of the word\r\n''Error''. So the *Fits* module will throw a *FitsError*.\r\n\r\n##Contribute\r\n\r\nIf you use SLiPy or have your own code related to spectroscopy or computing\r\nfor astronomy and think it would be a useful addition (or you find a\r\nbug/mistake) I'm more than open to suggested contributions/additions.\r\n\r\n##Author\r\n\r\nGeoffrey Lentner, B.S.  \r\nGraduate Research Assistant  \r\nDepartment of Physics & Astronomy  \r\nUniversity of Louisville\r\n\r\nWebsite: [glentner.github.io](http://glentner.github.io)\r\n\r\n# Documentation\r\n\r\n#<a name=FitsLoc></a>[Fits](SLiPy/Fits.py)\r\n\r\nManipulate FITS files. Import data into *Spectrum* objects. Filter results\r\nby right ascension and declination. Grab header elements. Search for attributes\r\nof the data such as distance, spectral type, etc.\r\n\r\n<a name=FindLoc></a>\r\n- **Find** (*toplevel* = './', *pattern* = '\\*.fits'):\r\n\r\n    Search for file paths below *toplevel* fitting *pattern*. Returns a list\r\n    of string values.\r\n\r\n<a name=RFindLoc></a>\r\n- **RFind** (*toplevel* = './', *pattern* = '\\*.fits'):\r\n\r\n    Recursively search for file paths below *toplevel* fitting *pattern*.\r\n    Returns a list of string values.\r\n\r\n<a name=GetDataLoc></a>\r\n- **GetData** ( \\**files*, \\*\\**kwargs*):\r\n\r\n\tImport data from FITS `files`. Returns a list of *Spectrum* objects.\r\n\r\n    |Options     | Defaults        | Descriptions\r\n    |------------|-----------------|------------------------------------------|\r\n    |*verbose*   | True            | display messages, progress               |\r\n    |*toplevel*  | ''              | request import from directory *toplevel* |  \r\n    |*pattern*   | '\\*.fits'       | pattern matching with *toplevel*         |\r\n    |*recursive* | False           | search recursively below *toplevel*      |\r\n    |*wavecal*   | True            | fit wavelength vector to data            |\r\n    |*crpix1*    | 'crpix1'        | reference pixel header keyword           |\r\n    |*crval1*    | 'crval1'        | value at reference pixel                 |\r\n    |*cdelt1*    | 'cdelt1'        | resolution (delta lambda)                |\r\n    |*xunits*    | 'Angstrom'      | wavelength units (astropy.units)         |\r\n    |*yunits*    | 'ergs cm-2 s-1' | units of the data                        |\r\n\r\n<a name=HeaderLoc></a>\r\n- **Header** ( *filename*, *keyword*, \\*\\**kwargs*):\r\n\r\n    Retrieve *keyword* from FITS header in file *filename*.\r\n    Return type depends on what is returned.\r\n\r\n<a name=SearchLoc></a>\r\n- **Search** ( \\**files*, \\*\\**kwargs*):\r\n\r\n    Extract object names from Fits *files* and use Simbad module\r\n    to resolve the *attribute* (a required keyword argument)\r\n    from the SIMBAD astronomical database. Currently available attributes\r\n    are 'Position', 'Distance', 'Sptype', and 'IDList'. Returns a list of\r\n    results (type depends on the values).\r\n\r\n    | Options     | Defaults  | Descriptions                         |\r\n    |-------------|-----------|--------------------------------------|\r\n    | *verbose*   | True      | display messages, progress           |\r\n    | *toplevel*  | None      | search under *toplevel* directory    |\r\n    | *pattern*   | '\\*.fits' | for files under *toplevel*           |\r\n    | *recursive* | False     | search recusively under *toplevel*   |\r\n    | *attribute* | None      | attribute to search for (no default) |\r\n\r\n<a name=PositionSortLoc></a>\r\n- **PositionSort** ( *center*, *radius*, \\**files*, \\*\\**kwargs* ):\r\n\r\n    Return a list of files from *files* that lie in a *radius* (in\r\n    decimal degrees) from *center*, based on the *ra* (right ascension) and\r\n    *dec* (declination).\r\n\r\n    | Options   | Defaults | Descriptions                             |\r\n    |-----------|----------|------------------------------------------|\r\n    *ra*        | 'pos1'   | header element for right ascension       |\r\n    *dec*       | 'pos2'   | header element for declination           |\r\n    *obj*       | 'object' | header element for object id             |\r\n    *raconvert* | True     | convert decimal hours to decimal degrees |\r\n    *verbose*   | True     | display messages, progress               |\r\n    *toplevel*  | None     | *toplevel* directory to look for files   |\r\n    *recursive* | False    | search *toplevel*ly below *toplevel*     |\r\n    *pattern*   |'\\*.fits' | glob *pattern* for file search           |\r\n    *useSimbad* | False    | use *Simbad* instead of header elements  |\r\n\r\n\r\n#<a name=DataTypeLoc></a>[DataType](SLiPy/DataType.py)\r\n\r\nObjects for representing astronomical data. Currently, this includes the\r\n*Spectrum* class and it's helper function *WaveVector*.\r\n\r\n<a name=WaveVectorLoc></a>\r\n- **WaveVector** ( *rpix*, *rval*, *delt*, *npix* ):\r\n\r\n    Construct numpy array of wavelength values where *rpix* is the reference\r\n    pixel index, *rval* is the wavelength at reference pixel, *delt* is the\r\n    resolutions (delta lambda), and *npix* is the length of desired array.\r\n\r\n<a name=SpectrumLoc></a>\r\n- class **Spectrum** ( *filename*, *wavelengths* = None, \\*\\**kwargs* ):\r\n\r\n    The *Spectrum* class is a container for a *data* array and it's\r\n    corresponding wavelength calibration, *wave*. These are accessed with\r\n    .data and .wave, respectively. The data is read in from the file,\r\n    *filename*. Alternatively, it can be initialized by a set of numpy\r\n    arrays. To do this, *filename* can actually be the *data* array and\r\n    if this is the case, *wavelengths* must be assigned an array of equal\r\n    length containing the corresponding wavelength values.\r\n\r\n    The following operations are defined:\r\n    +, -, \\*, /, +=, -=, \\*=, /=. For each of these, if the second operand is\r\n    a scalar, the operation is performed pixel-wise on the *data* array. If\r\n    the other operand is also a *Spectrum* object, the RHS operand is\r\n    *resampled* onto the same pixel space as the LHS. The domain of the RHS\r\n    *wave* array must be entirely contained by or equivalent to the LHS\r\n    *wave* domain.\r\n\r\n    The *wave* and *data* arrays are given units 'a la *astropy.units*;\r\n    if the spectrum is initialized via numpy arrays, the units are only\r\n    applied if there are none currently.\r\n\r\n    | Options   | Defaults       | Descriptions                    |\r\n    |-----------|----------------|---------------------------------|\r\n    | *wavecal* | True           | fit wavelength vector to data   |\r\n    | *crpix1*  | 'crpix1'       | reference pixel header keyword  |\r\n    | *crval1*  | 'crval1'       | value at reference pixel        |\r\n    | *cdelt1*  | 'cdelt1'       | resolution (delta lambda)       |\r\n    | *xunit*   | 'Angstrom'     | units of wavelength from header |\r\n    | *yunit*   | 'erg cm-2 s-1' | units of data                   |\r\n\r\n    Member functions:\r\n\r\n    - *.resample* ( \\**args*, \\*\\**kwargs* ):\r\n\r\n        If given a single argument, it is taken to be a *Spectrum* object,\r\n        and *self* is resampled onto the pixel space of the other spectrum.\r\n        Otherwise, three arguments are expected. The first and second argument\r\n        should define the lower and upper wavelength value of a domain,\r\n        respectively. The third argument should be the number of elements\r\n        (pixels) for the new domain. Think numpy.linspace().\r\n\r\n        | Options | Defaults | Descriptions                         |\r\n        |---------|----------|--------------------------------------|\r\n        | *kind*  | 'linear' | passed to scipy.interpolate.interp1d |\r\n\r\n    - *.copy* ():\r\n\r\n        Essentially a wrapper to *deepcopy()*. To say SpectrumA = SpectrumB\r\n        implies that SpectrumA *is* SpectrumB. If you want to create a new\r\n        spectrum *equal* to another, say SpectrumA = SpectrumB.copy()\r\n\r\n\r\n#<a name=SimbadLoc></a>[Simbad](SLiPy/Simbad.py)\r\n\r\nThis module allows the user to query the SIMBAD astronomical database from\r\ninside Python or shell commands/scripts. It's four current major functions\r\n*Position*, *Distance*, *Sptype*, and *IDList* return real variables with\r\nappropriate types ready for use.\r\n\r\nAs a shell script:\r\n\r\n```\r\n$ Simbad.py\r\n\r\n usage: Simbad.py @Attribute <identifier> [**kwargs]\r\n\r\n The 'Attribute' points to a function within this module and indicates\r\n what is to be run. Execute 'Simbad.py @Attribute help' for usage details of\r\n a specific function. Currently available attributes are: `Position`,\r\n `Distance`, `Sptype` and `IDList`.\r\n\r\n The identifier names can be anything recognized by SIMBAD (e.g., Regulus,\r\n \"alpha leo\", \"HD 121475\", \"del cyg\", etc ...) if the name is two parts make\r\n sure to use quotation to enclose it.\r\n\r\n The **kwargs is the conventional reference to Python keyword arguments.\r\n These should be specific to the 'Attribute' being pointed to.\r\n```\r\n\r\n<a name=PositionLoc></a>\r\n- **Position** ( *identifier*, \\*\\**kwargs* ):\r\n\r\n    Return the right ascension and declination in decimal degrees of\r\n    *identifier* as a pair.\r\n\r\n    | Options   | Defaults    | Descriptions                     |\r\n    |-----------|-------------|----------------------------------|\r\n    | *parse*   | True        | parse return file from SIMBAD    |\r\n    | *full*    | False       | return more detailed information |\r\n\r\n    Example:\r\n    ```python\r\n    ra, dec = Simbad.Position('Sirius')\r\n    ```\r\n\r\n<a name=DistanceLoc></a>\r\n- **Distance** ( *identifier*, \\*\\**kwargs* ):\r\n\r\n    Return the distance in parsecs to *identifier*.\r\n\r\n    | Options   | Defaults    | Descriptions                     |\r\n    |-----------|-------------|----------------------------------|\r\n    | *parse*   | True        | parse return file from SIMBAD    |\r\n    | *full*    | False       | return more detailed information |\r\n\r\n    Example:\r\n    ```python\r\n    distance = Simbad.Distance('rigel kent')\r\n    ```\r\n\r\n<a name=SptypeLoc></a>\r\n- **Sptype** ( *identifier*, \\*\\**kwargs* ):\r\n\r\n    Return the spectral type of *identifier* as resolved by SIMBAD.\r\n\r\n    | Options   | Defaults    | Descriptions                     |\r\n    |-----------|-------------|----------------------------------|\r\n    | *parse*   | True        | parse return file from SIMBAD    |\r\n    | *full*    | False       | return more detailed information |\r\n\r\n    Example:\r\n    ```python\r\n    # returns 'B8IVn' (HD 87901 is Regulus)\r\n    sptype = Simbad.Sptype('HD 87901')\r\n    ```\r\n\r\n<a name=IDListLoc></a>\r\n- **IDList** ( *identifier*, \\*\\**kwargs* ):\r\n\r\n    Return a list of alternate IDs for *identifier*.\r\n\r\n    | Options   | Defaults    | Descriptions                     |\r\n    |-----------|-------------|----------------------------------|\r\n    | *parse*   | True        | parse return file from SIMBAD    |\r\n    | *full*    | False       | return more detailed information |\r\n\r\n    Example:\r\n    ```python\r\n    other_names = Simbad.IDList('proxima centauri')\r\n    ```\r\n\r\n#<a name=CorrelateLoc></a>[Correlate](SLiPy/Correlate.py)\r\n\r\nCorrelation functions for astronomical data.\r\n\r\n<a name=XCorrLoc></a>\r\n- **XCorr** ( *spectrumA*, *spectrumB*, \\*\\**kwargs* ):\r\n\r\n    The function returns an integer value representing the best shift within\r\n    a *lag* based on the computed RMS of each configuration.\r\n\r\n    | Options   | Defaults    | Descriptions                     |\r\n    |-----------|-------------|----------------------------------|\r\n    | *lag*     | 25          | pixel range to shift over        |\r\n\r\n#<a name=TelluricLoc></a>[Telluric](SLiPy/Telluric.py)\r\n\r\nRemoval of atmospheric absorption lines in spectra.\r\n\r\n<a name=CorrectLoc></a>\r\n- **Correct** ( *spectrum*, \\**calibration*, \\*\\**kwargs* ):\r\n\r\n\tPerform a telluric correction on *spectrum* with one or more\r\n\t*calibration* spectra. If more than one calibration spectrum is\r\n\tprovided, the one with the best fit after performing both a\r\n\thorizontal cross correlation and a vertical amplitude fit is used.\r\n\tThe spectrum and all the calibration spectra must have the same\r\n\tnumber of pixels (elements). If a horizontal shift in the calibration\r\n\tspectra is appropriate, only the corresponding range of the spectrum\r\n\tis divided out!\r\n\r\n    **Notice** Your spectra must be continuum normalized for this to work!\r\n\r\n    | Options   | Defaults        | Descriptions                         |\r\n    |-----------|-----------------|--------------------------------------|\r\n    | *lag*     | 25              | pixel range to shift over            |\r\n    | *range*   | (0.5, 2.0, 151) | numpy.linspace for amplitude fitting |\r\n\r\n    ![example](Figures/HD192640.png)\r\n\r\n    **Figure 1:** The above figure is an example of applying the\r\n    **Telluric.Correct()** algorithm to a spectrum. In this case, six spectra of\r\n    *Regulus* from the Elodie archive were used as calibration spectra.\r\n\r\n\r\n#<a name=VelocityLoc></a>[Velocity](SLiPy/Velocity.py)\r\n\r\nRadial velocity corrections for 1D spectra.\r\n\r\n<a name=HelioCorrectLoc></a>\r\n- **HelioCorrect** ( *observatory*, \\**spectra*, \\*\\**kwargs* ):\r\n\r\n    Perform heliocentric velocity corrects on *spectra* based on\r\n    *observatory* parameters (*longitude*, *latitude*, *altitude*) and the\r\n    member attributes, *ra* (right ascension), *dec* (declination), and *jd*\r\n    (julian date) from the *spectra*.\r\n\r\n    | Options    | Defaults        | Descriptions               |\r\n    |------------|-----------------|----------------------------|\r\n    | *verbose*  | False           | display messages, progress |\r\n\r\n<a name=BaryCorrectLoc></a>\r\n- **BaryCorrect** ( *observatory*, \\**spectra*, \\*\\**kwargs* ):\r\n\r\n    Perform barycentric velocity corrects on *spectra* based on\r\n    *observatory* parameters (*longitude*, *latitude*, *altitude*) and the\r\n    member attributes, *ra* (right ascension), *dec* (declination), and *jd*\r\n    (julian date) from the *spectra*.\r\n\r\n    | Options    | Defaults        | Descriptions               |\r\n    |------------|-----------------|----------------------------|\r\n    | *verbose*  | False           | display messages, progress |\r\n\r\n<a name=IrafInputLoc></a>\r\n- **IrafInput** ( \\**files*, \\*\\**kwargs* ):\r\n\r\n\tBuild an input file for IRAF's rvcorrect task.\r\n\r\n\t*files* should be a list of FITS file names to build the output table for.\r\n\tThe user can optionally specify a *toplevel* directory to search for files\r\n    under. If *outfile* is given, write results to the file.\r\n\r\n    | Options     | Defaults  | Descriptions                          |\r\n    |-------------|-----------|---------------------------------------|\r\n    | *toplevel*  | None      | search *toplevel* directory for files |\r\n    | *pattern*   | '\\*.fits' | pattern matching under *toplevel*     |\r\n    | *recursive* | False     | search recusively under *toplevel*    |\r\n    | *outfile*   | None      | write lines to file named *outfile*   |\r\n\r\n\r\n#<a name=ObservatoryLoc></a>[Observatory](SLiPy/Observatory.py)\r\n\r\nDefine observatory parameter similar to the IRAF task. All observatories\r\nshould follow the following pattern. The user can add as many as they like\r\nto this module. I welcome suggestions.\r\n\r\n<a name=OHPLoc></a>\r\n```Python\r\nclass OHP(Observatory):\r\n\t\"\"\"\r\n\tThe Observatoire de Haute-Provence, France.\r\n\t\"\"\"\r\n\tdef __init__(self):\r\n\t\tself.name      = 'Observatoire de Haute-Provence'\r\n\t\tself.latitude  = 43.9308334 # degrees N\r\n\t\tself.longitude = 356.28667  # degrees W\r\n\t\tself.altitude  = 650        # meters\r\n```\r\n\r\n#<a name=PlotLoc></a>[Plot](SLiPy/Plot.py)\r\n\r\nConvenient wrappers to matplotlib for plotting spectra. A *SPlot* simply\r\ncreates a handle to remember figure attributes, to quickly go from looking\r\nat one spectra to another. One can also *overlay* spectra.\r\n\r\n<a name=SPlotLoc></a>\r\n- class **SPlot** ( *spectrum*, \\*\\**kwargs* ):\r\n\r\n    Spectrum Plot - Create figure of *spectrum*.\r\n\r\n    | Options  | Defaults   | Descriptions         |\r\n    |----------|------------|----------------------|\r\n    | *marker* | 'b-'       | marker for data      |\r\n    | *label*  | 'spectrum' | name of object       |\r\n    | *usetex* | False      | render with pdflatex |\r\n\r\n    The following member functions call pyplot equivalent:  \r\n    **xlim**, **ylim**, **xlabel**, **ylabel**, **title**, **legend**,\r\n    **text**, **grid**, **close**.\r\n\r\n    Here, when these function are called, the arguments are passed to\r\n    matplotlib; however, these calls are remembered. So when you go to *draw*\r\n    the figure again, you are back where you left off.\r\n\r\n    - *draw*( ):\r\n\r\n        Rebuild and render the figure.\r\n\r\n    - *refresh*( ):\r\n\r\n        Re-render (refresh) the figure, without clearing the axis.\r\n\r\n    - *txtclear*( ):\r\n\r\n        Clear all the calls to *text*( ) from the figure.\r\n\r\n    - *xoffset*( *value* ):\r\n\r\n        Switch either on or off (*value* = True | False) the horizontal offset.\r\n\r\n    - *yoffset*( *value* ):\r\n\r\n        Switch either on or off (*value* = True | False) the vertical offset.\r\n\r\n    - *overlay*( \\**splots* ):\r\n\r\n        Given one or more *splots*, *overlay* the figures.\r\n\r\n    - *restore*( ):\r\n\r\n        Restore the figure to only the original spectrum.\r\n\r\n    - *save*( *filename* ):\r\n\r\n        Save the figure to a file called *filename*. The file format is derived\r\n        from the extention of *filename*.\r\n\r\n<a name=IterateLoc></a>\r\n- **Iterate**( \\**splots*, \\*\\**kwargs* ):\r\n\r\n\tIterate thru *splots* to inspect data, the user marks spectra of\r\n\tinterest. The function returns a list of *keepers*.\r\n\r\n    | Options | Defaults  | Descriptions          |\r\n    |---------|-----------|-----------------------|\r\n    | *keep*  | 'name'    | alternative is 'plot' |\r\n","google":"UA-58405300-1","note":"Don't delete this file! It's used internally to help with page regeneration."}