{"name":"SLiPy","tagline":"A Spectroscopy and astrophysics Library for Python 3","body":"# [SLiPy](http://glentner.github.io/SLiPy)\r\n\r\n#### A Spectroscopy and astrophysics Library for Python 3\r\n\r\nThis Python package is an expanding code base for doing computational\r\nastronomy, particularly spectroscopy. It contains both a *Spectrum* class\r\nfor handling spectra as objects (with +, -, \\*, /, etc... operations defined)\r\nand a growing suite of analysis tools.\r\n\r\n**Dependencies:**\r\nPython 3.x,\r\n[astropy](http://www.astropy.org),\r\n[matplotlib](http://matplotlib.org),\r\n[numpy](http://www.numpy.org),\r\n[scipy](http://www.scipy.org)\r\n\r\n[![astropy](http://img.shields.io/badge/powered%20by-AstroPy-orange.svg?style=flat)](http://www.astropy.org/)\r\n[![GitHub license](http://img.shields.io/badge/license-GPLv3-blue.svg?style=flat)](http://www.gnu.org/copyleft/gpl.html)\r\n\r\nQuick note: the subpackage **astrolibpy** was not developed\r\nby me. It was coded by Sergey Koposov (@segasai) at Cambridge (then at least).\r\nI found it useful for performing velocity corrections on my spectroscopic\r\ndata. I've modified several modules such that it can be imported and used in\r\nPython 3.x. See his README file.\r\n\r\n## Contents\r\n\r\nSLiPy is split into several components. The principle component is the\r\nsubpackage **SLiPy** itself, which contains all the relevant\r\nfunctionality. Further, **Data** is a package I'm working on that will provide\r\nan API for searching astronomical data archives in a simple way. The other two\r\nsubpackages **Framework** and **astrolibpy** are of utility to the project but\r\nnot necessarily intended for export. As stated previously, astrolibpy was not\r\ndeveloped by me, only modified. I'm not going to document it's usage here. Its\r\nname is unfortunate for me as it is a bit over done with the convention I was\r\nalready using, but for consistency I will keep it as it was from the author.\r\n\r\nThe following modules are elevated to the package level and are available\r\nto import:\r\n\r\n| SLiPy/ | Functions/Classes |\r\n|---------|-------------------|\r\n|[**Fits**](#FitsLoc)|[Find](#FindLoc), [RFind](#RFindLoc), [GetData](#GetDataLoc), [Header](#HeaderLoc), [Search](#SearchLoc), [PositionSort](#PositionSortLoc), |\r\n|[**DataType**](#DataTypeLoc)|[WaveVector](#WaveVectorLoc), [Spectrum](#SpectrumLoc), |\r\n|[**Simbad**](#SimbadLoc)|[Position](#PositionLoc), [Distance](#DistanceLoc), [Sptype](#SptypeLoc), [IDList](#IDListLoc), |\r\n|[**Correlate**](#CorrelateLoc)|[XCorr](#XCorrLoc), |\r\n|[**Telluric**](#TelluricLoc)|[Correct](#CorrectLoc), |\r\n|[**Velocity**](#VelocityLoc)|[HelioCorrect](#HelioCorrectLoc), [BaryCorrect](#BaryCorrectLoc), [IrafInput](#IrafInputLoc),  |\r\n|[**Observatory**](#ObservatoryLoc)|[...](#OHPLoc), |\r\n|[**Plot**](#PlotLoc)|[SPlot](#SPlotLoc), [Iterate](#IterateLoc), |\r\n|[**Profile**](#ProfileLoc)|[Select](#SelectLoc), [Fit](#FitLoc), [Extract](#ExtractLoc),   |\r\n|[**Montage**](#MontageLoc)|[SolveGrid](#MSolveGridLoc), [Mosaic](#MMosaicLoc), [SubField](#MSubFieldLoc), [Field](#MFieldLoc), |\r\n\r\n<br>\r\n\r\n| SLiPy/Data | Functions/Classes |\r\n|------------|-------------------|\r\n|[**Elodie**](#ElodieLoc)|[Archive](#EArchiveLoc), [Script](#EScriptLoc), [Download](#EDownloadLoc), |\r\n\r\n## Installation\r\n\r\nTo install SLiPy, there is no setup procedure. Simply download the package,\r\neither by clicking on the download link for a *tar* or *zip* archive or by\r\ncloning it.\r\n\r\nExtract it's contents to wherever you like in a directory (ostensibly named\r\n*slipy*, but actually you can call this library whatever you want as well\r\nbecause all the imports are *relative*). Then add the parent directory to your\r\n*PYTHONPATH* if it isn't already. For example:\r\n\r\n```\r\n$ cd\r\n$ git clone http://github.com/glentner/slipy\r\n$ echo \"export PYTHONPATH=$PYTHONPATH:~\" >> ~/.bashrc\r\n```\r\n\r\nAnd your ready to go!\r\n\r\n## Exceptions\r\n\r\nSLiPy attempts to catch all foreseeable exceptions and re-throw them under a\r\ncommon handle with a human readable message. There is a unique exception class\r\nfor every module, all derived from a common *SlipyError*. The naming convention \r\nis for a module's exception to be named after the module with the addition of \r\nthe word *Error*. So the *Fits* module will throw a *FitsError*. These are meant\r\nto handle erros internally. The user need not worry about these in an \r\ninteractive session; however, inside of scipts you might catch *SlipyError*.\r\nFor finer control, catch the individual exceptions (e.g., *Fits.FitsError*).\r\n\r\n## Contribute\r\n\r\nIf you use SLiPy or have your own code related to spectroscopy or computing\r\nfor astronomy and think it would be a useful addition (or you find a\r\nbug/mistake) I'm more than open to suggested contributions/additions.\r\n\r\n## Author(s)\r\n\r\n[Geoffrey Lentner](http://glentner.github.io), B.S.  \r\nGraduate Research Assistant  \r\nDepartment of Physics & Astronomy  \r\nUniversity of Louisville\r\n\r\nSignificant intellectual contributions have been made by my thesis advisor,\r\nspecifically in terms of the science behind much of this package.\r\n\r\n[James Lauroesch](http://www.physics.louisville.edu/jtl/), Ph.D.  \r\nAssociate Professor  \r\nDepartment of Physics & Astronomy  \r\nUniversity of Louisville\r\n\r\n\r\n##Acknowledge SLiPy\r\n\r\nIf you have made use of SLiPy in your project/research, you can acknowledge\r\nyour use in the following ways:\r\n\r\n**Publications**  \r\nThis research has made use of SLiPy, an open source spectroscopy and\r\nastrophysics library for Python 3 (G. Lentner, 2015).\r\n\r\n**Projects**  \r\nIf your code either makes use of or borrows from SLiPy, a good way to reference\r\nthis is with a [shield](http://shields.io) in your README file.\r\n\r\n[![SLiPy](http://img.shields.io/badge/running-SLiPy-green.svg?style=flat)](http://glentner.github.io/SLiPy)\r\n\r\nThe above badge is generated using the following snippet\r\n```\r\n[![SLiPy](http://img.shields.io/badge/running-SLiPy-green.svg?style=flat)](http://glentner.github.io/SLiPy)\r\n```\r\n\r\n# Documentation\r\n\r\n<br>\r\n##<a name=FitsLoc></a>[Fits](SLiPy/Fits.py)\r\n\r\nManipulate FITS files. Import data into *Spectrum* objects. Filter results\r\nby right ascension and declination. Grab header elements. Search for attributes\r\nof the data such as distance, spectral type, etc.\r\n\r\n<a name=FindLoc></a>\r\n- **Find** (*toplevel* = './', *pattern* = '\\*.fits'):\r\n\r\n    Search for file paths below *toplevel* fitting *pattern*. Returns a list\r\n    of string values.\r\n\r\n<a name=RFindLoc></a>\r\n- **RFind** (*toplevel* = './', *pattern* = '\\*.fits'):\r\n\r\n    Recursively search for file paths below *toplevel* fitting *pattern*.\r\n    Returns a list of string values.\r\n\r\n<a name=GetDataLoc></a>\r\n- **GetData** ( \\**files*, \\*\\**kwargs*):\r\n\r\n\tImport data from FITS *files*. Returns a list of *Spectrum* objects.\r\n\r\n    |Options     | Defaults        | Descriptions\r\n    |------------|-----------------|------------------------------------------|\r\n    |*verbose*   | True            | display messages, progress               |\r\n    |*toplevel*  | ''              | request import from directory *toplevel* |  \r\n    |*pattern*   | '\\*.fits'       | pattern matching with *toplevel*         |\r\n    |*recursive* | False           | search recursively below *toplevel*      |\r\n    |*wavecal*   | True            | fit wavelength vector to data            |\r\n    |*crpix1*    | 'crpix1'        | reference pixel header keyword           |\r\n    |*crval1*    | 'crval1'        | value at reference pixel                 |\r\n    |*cdelt1*    | 'cdelt1'        | resolution (delta lambda)                |\r\n    |*xunits*    | 'Angstrom'      | wavelength units (astropy.units)         |\r\n    |*yunits*    | 'ergs cm-2 s-1' | units of the data                        |\r\n\r\n<a name=HeaderLoc></a>\r\n- **Header** ( *filename*, *keyword* = None, \\*\\**kwargs*):\r\n\r\n    Retrieve *keyword* from FITS header in file *filename*.\r\n    Return type depends on what is returned. If no keyword is\r\n\tgiven, the entire header object is returned.\r\n\r\n<a name=SearchLoc></a>\r\n- **Search** ( \\**files*, \\*\\**kwargs*):\r\n\r\n    Extract object names from Fits *files* and use Simbad module\r\n    to resolve the *attribute* (a required keyword argument)\r\n    from the SIMBAD astronomical database. Currently available attributes\r\n    are 'Position', 'Distance', 'Sptype', and 'IDList'. Returns a list of\r\n    results (type depends on the values).\r\n\r\n    | Options     | Defaults  | Descriptions                         |\r\n    |-------------|-----------|--------------------------------------|\r\n    | *verbose*   | True      | display messages, progress           |\r\n    | *toplevel*  | None      | search under *toplevel* directory    |\r\n    | *pattern*   | '\\*.fits' | for files under *toplevel*           |\r\n    | *recursive* | False     | search recusively under *toplevel*   |\r\n    | *attribute* | None      | attribute to search for (no default) |\r\n\r\n<a name=PositionSortLoc></a>\r\n- **PositionSort** ( *center*, *radius*, \\**files*, \\*\\**kwargs* ):\r\n\r\n    Return a list of files from *files* that lie in a *radius* (in\r\n    decimal degrees) from *center*, based on the *ra* (right ascension) and\r\n    *dec* (declination).\r\n\r\n    | Options   | Defaults | Descriptions                             |\r\n    |-----------|----------|------------------------------------------|\r\n    *ra*        | 'pos1'   | header element for right ascension       |\r\n    *dec*       | 'pos2'   | header element for declination           |\r\n    *obj*       | 'object' | header element for object id             |\r\n    *raconvert* | True     | convert decimal hours to decimal degrees |\r\n    *verbose*   | True     | display messages, progress               |\r\n    *toplevel*  | None     | *toplevel* directory to look for files   |\r\n    *recursive* | False    | search below *toplevel* recursively      |\r\n    *pattern*   |'\\*.fits' | glob *pattern* for file search           |\r\n    *useSimbad* | False    | use *Simbad* instead of header elements  |\r\n\r\n\r\n<br>\r\n##<a name=DataTypeLoc></a>[DataType](SLiPy/DataType.py)\r\n\r\nObjects for representing astronomical data. Currently, this includes the\r\n*Spectrum* class and it's helper function *WaveVector*.\r\n\r\n<a name=WaveVectorLoc></a>\r\n- **WaveVector** ( *rpix*, *rval*, *delt*, *npix* ):\r\n\r\n    Construct numpy array of wavelength values where *rpix* is the reference\r\n    pixel index, *rval* is the wavelength at reference pixel, *delt* is the\r\n    resolutions (delta lambda), and *npix* is the length of desired array.\r\n\r\n<a name=SpectrumLoc></a>\r\n- class **Spectrum** ( *filename*, *wavelengths* = None, \\*\\**kwargs* ):\r\n\r\n    The *Spectrum* class is a container for a *data* array and it's\r\n    corresponding wavelength calibration, *wave*. These are accessed with\r\n    .data and .wave, respectively. The data is read in from the file,\r\n    *filename*. Alternatively, it can be initialized by a set of numpy\r\n    arrays. To do this, *filename* can actually be the *data* array and\r\n    if this is the case, *wavelengths* must be assigned an array of equal\r\n    length containing the corresponding wavelength values.\r\n\r\n    The following operations are defined:\r\n    +, -, \\*, /, +=, -=, \\*=, /=. For each of these, if the second operand is\r\n    a scalar, the operation is performed pixel-wise on the *data* array. If\r\n    the other operand is also a *Spectrum* object, the RHS operand is\r\n    *resampled* onto the same pixel space as the LHS. The domain of the RHS\r\n    *wave* array must be entirely contained by or equivalent to the LHS\r\n    *wave* domain.\r\n\r\n    The *wave* and *data* arrays are given units 'a la *astropy.units*;\r\n    if the spectrum is initialized via numpy arrays, the units are only\r\n    applied if there are none currently.\r\n\r\n    | Options   | Defaults       | Descriptions                   |\r\n    |-----------|----------------|--------------------------------|\r\n    | *wavecal* | True           | fit wavelength vector to data  |\r\n    | *crpix1*  | 'crpix1'       | reference pixel header keyword |\r\n    | *crval1*  | 'crval1'       | value at reference pixel       |\r\n    | *cdelt1*  | 'cdelt1'       | resolution (delta lambda)      |\r\n    | *xunits*  | 'Angstrom'     | units for wavelength array     |\r\n    | *yunits*  | 'erg cm-2 s-1' | units for data array           |\r\n\r\n    <br>\r\n    Member functions:\r\n\r\n    - *resample* ( \\**args*, \\*\\**kwargs* ):\r\n\r\n        If given a single argument, it is taken to be a *Spectrum* object,\r\n        and *self* is resampled onto the pixel space of the other spectrum.\r\n        Otherwise, three arguments are expected. The first and second argument\r\n        should define the lower and upper wavelength value of a domain,\r\n        respectively. The third argument should be the number of elements\r\n        (pixels) for the new domain. Think numpy.linspace().\r\n\r\n        | Options | Defaults | Descriptions                         |\r\n        |---------|----------|--------------------------------------|\r\n        | *kind*  | 'linear' | passed to scipy.interpolate.interp1d |\r\n\r\n    - *copy* ():\r\n\r\n        Essentially a wrapper to *deepcopy()*. To say SpectrumA = SpectrumB\r\n        implies that SpectrumA *is* SpectrumB. If you want to create a new\r\n        spectrum *equal* to another, say SpectrumA = SpectrumB.copy()\r\n\r\n\r\n<br>\r\n##<a name=SimbadLoc></a>[Simbad](SLiPy/Simbad.py)\r\n\r\nThis module allows the user to query the SIMBAD astronomical database from\r\ninside Python or shell commands/scripts. It's four current major functions\r\n*Position*, *Distance*, *Sptype*, and *IDList* return real variables with\r\nappropriate types ready for use.\r\n\r\nAs a shell script:\r\n\r\n```\r\n$ Simbad.py\r\n\r\n usage: Simbad.py @Attribute <identifier> [**kwargs]\r\n\r\n The 'Attribute' points to a function within this module and indicates\r\n what is to be run. Execute 'Simbad.py @Attribute help' for usage details of\r\n a specific function. Currently available attributes are: `Position`,\r\n `Distance`, `Sptype` and `IDList`.\r\n\r\n The identifier names can be anything recognized by SIMBAD (e.g., Regulus,\r\n \"alpha leo\", \"HD 121475\", \"del cyg\", etc ...) if the name is two parts make\r\n sure to use quotation to enclose it.\r\n\r\n The **kwargs is the conventional reference to Python keyword arguments.\r\n These should be specific to the 'Attribute' being pointed to.\r\n```\r\n\r\n<a name=PositionLoc></a>\r\n- **Position** ( *identifier*, \\*\\**kwargs* ):\r\n\r\n    Return the right ascension and declination in decimal degrees of\r\n    *identifier* as a pair.\r\n\r\n    | Options   | Defaults    | Descriptions                     |\r\n    |-----------|-------------|----------------------------------|\r\n    | *parse*   | True        | parse return file from SIMBAD    |\r\n    | *full*    | False       | return more detailed information |\r\n\r\n    <br>\r\n    Example:\r\n    ```python\r\n    ra, dec = Simbad.Position('Sirius')\r\n    ```\r\n\r\n<a name=DistanceLoc></a>\r\n- **Distance** ( *identifier*, \\*\\**kwargs* ):\r\n\r\n    Return the distance in parsecs to *identifier*.\r\n\r\n    | Options   | Defaults    | Descriptions                     |\r\n    |-----------|-------------|----------------------------------|\r\n    | *parse*   | True        | parse return file from SIMBAD    |\r\n    | *full*    | False       | return more detailed information |\r\n\r\n    <br>\r\n    Example:\r\n    ```python\r\n    distance = Simbad.Distance('rigel kent')\r\n    ```\r\n\r\n<a name=SptypeLoc></a>\r\n- **Sptype** ( *identifier*, \\*\\**kwargs* ):\r\n\r\n    Return the spectral type of *identifier* as resolved by SIMBAD.\r\n\r\n    | Options   | Defaults    | Descriptions                     |\r\n    |-----------|-------------|----------------------------------|\r\n    | *parse*   | True        | parse return file from SIMBAD    |\r\n    | *full*    | False       | return more detailed information |\r\n\r\n    <br>\r\n    Example:\r\n    ```python\r\n    # returns 'B8IVn' (HD 87901 is Regulus)\r\n    sptype = Simbad.Sptype('HD 87901')\r\n    ```\r\n\r\n<a name=IDListLoc></a>\r\n- **IDList** ( *identifier*, \\*\\**kwargs* ):\r\n\r\n    Return a list of alternate IDs for *identifier*.\r\n\r\n    | Options   | Defaults    | Descriptions                     |\r\n    |-----------|-------------|----------------------------------|\r\n    | *parse*   | True        | parse return file from SIMBAD    |\r\n    | *full*    | False       | return more detailed information |\r\n\r\n    <br>\r\n    Example:\r\n    ```python\r\n    other_names = Simbad.IDList('proxima centauri')\r\n    ```\r\n\r\n\r\n<br>\r\n##<a name=CorrelateLoc></a>[Correlate](SLiPy/Correlate.py)\r\n\r\nCorrelation functions for astronomical data.\r\n\r\n<a name=XCorrLoc></a>\r\n- **XCorr** ( *spectrumA*, *spectrumB*, \\*\\**kwargs* ):\r\n\r\n    The function returns an integer value representing the best shift within\r\n    a *lag* based on the computed RMS of each configuration.\r\n\r\n    | Options   | Defaults    | Descriptions                     |\r\n    |-----------|-------------|----------------------------------|\r\n    | *lag*     | 25          | pixel range to shift over        |\r\n\r\n\r\n<br>\r\n##<a name=TelluricLoc></a>[Telluric](SLiPy/Telluric.py)\r\n\r\nRemoval of atmospheric absorption lines in spectra.\r\n\r\n<a name=CorrectLoc></a>\r\n- **Correct** ( *spectrum*, \\**calibration*, \\*\\**kwargs* ):\r\n\r\n\tPerform a telluric correction on *spectrum* with one or more\r\n\t*calibration* spectra. If more than one calibration spectrum is\r\n\tprovided, the one with the best fit after performing both a\r\n\thorizontal cross correlation and a vertical amplitude fit is used.\r\n\tThe spectrum and all the calibration spectra must have the same\r\n\tnumber of pixels (elements). If a horizontal shift in the calibration\r\n\tspectra is appropriate, only the corresponding range of the spectrum\r\n\tis divided out!\r\n\r\n    **Notice** Your spectra must be continuum normalized for this to work!\r\n\r\n    | Options   | Defaults        | Descriptions                         |\r\n    |-----------|-----------------|--------------------------------------|\r\n    | *lag*     | 25              | pixel range to shift over            |\r\n    | *range*   | (0.5, 2.0, 151) | numpy.linspace for amplitude fitting |\r\n\r\n    ![example](Figures/HD192640.png)\r\n\r\n    **Figure 1:** The above figure is an example of applying the\r\n    **Telluric.Correct()** algorithm to a spectrum. In this case, six spectra of\r\n    *Regulus* from the Elodie archive were used as calibration spectra.\r\n\r\n\r\n<br>\r\n##<a name=VelocityLoc></a>[Velocity](SLiPy/Velocity.py)\r\n\r\nRadial velocity corrections for 1D spectra.\r\n\r\n<a name=HelioCorrectLoc></a>\r\n- **HelioCorrect** ( *observatory*, \\**spectra*, \\*\\**kwargs* ):\r\n\r\n    Perform heliocentric velocity corrects on *spectra* based on\r\n    *observatory* parameters (*longitude*, *latitude*, *altitude*) and the\r\n    member attributes, *ra* (right ascension), *dec* (declination), and *jd*\r\n    (julian date) from the *spectra*. These should all have units.\r\n\r\n    | Options    | Defaults        | Descriptions               |\r\n    |------------|-----------------|----------------------------|\r\n    | *verbose*  | False           | display messages, progress |\r\n\r\n<a name=BaryCorrectLoc></a>\r\n- **BaryCorrect** ( *observatory*, \\**spectra*, \\*\\**kwargs* ):\r\n\r\n    Perform barycentric velocity corrects on *spectra* based on\r\n    *observatory* parameters (*longitude*, *latitude*, *altitude*) and the\r\n    member attributes, *ra* (right ascension), *dec* (declination), and *jd*\r\n    (julian date) from the *spectra*. These should all have units.\r\n\r\n    | Options    | Defaults        | Descriptions               |\r\n    |------------|-----------------|----------------------------|\r\n    | *verbose*  | False           | display messages, progress |\r\n\r\n<a name=IrafInputLoc></a>\r\n- **IrafInput** ( \\**files*, \\*\\**kwargs* ):\r\n\r\n\tBuild an input file for IRAF's rvcorrect task.\r\n\r\n\t*files* should be a list of FITS file names to build the output table for.\r\n\tThe user can optionally specify a *toplevel* directory to search for files\r\n    under. If *outfile* is given, write results to the file.\r\n\r\n    | Options     | Defaults  | Descriptions                          |\r\n    |-------------|-----------|---------------------------------------|\r\n    | *toplevel*  | None      | search *toplevel* directory for files |\r\n    | *pattern*   | '\\*.fits' | pattern matching under *toplevel*     |\r\n    | *recursive* | False     | search recusively under *toplevel*    |\r\n    | *outfile*   | None      | write lines to file named *outfile*   |\r\n\r\n\r\n<br>\r\n##<a name=ObservatoryLoc></a>[Observatory](SLiPy/Observatory.py)\r\n\r\nDefine observatory parameter similar to the IRAF task. All observatories\r\nshould follow the following pattern. The user can add as many as they like\r\nto this module. I welcome suggestions.\r\n\r\n<a name=OHPLoc></a>\r\n```Python\r\nclass OHP(Observatory):\r\n    \"\"\"\r\n    The Observatoire de Haute-Provence, France.\r\n    \"\"\"\r\n    def __init__(self):\r\n        self.name      = 'Observatoire de Haute-Provence'\r\n        self.longitude = 356.28667  * u.degree # West\r\n        self.latitude  = 43.9308334 * u.degree # North\r\n        self.altitude  = 650        * u.meter\r\n        self.timezone  = 1          * u.hourangle\r\n```\r\n\r\nThere are currently 69 defined observatories:\r\n\r\n| Class ID       | Observatory Name                                         |\r\n|----------------|----------------------------------------------------------|\r\n|            OHP |              The Observatoire de Haute-Provence, France. |\r\n|           KPNO |                           Kitt Peak National Observatory |\r\n|           WIYN |                                         WIYN Observatory |\r\n|           CTIO |                   Cerro Tololo Interamerican Observatory |\r\n|        LASILLA |                 European Southern Observatory: La Silla. |\r\n|        PARANAL |                   European Southern Observatory: Paranal |\r\n|           LICK |                                         Lick Observatory |\r\n|           MMTO |                                          MMT Observatory |\r\n|           CFHT |                           Canada-France-Hawaii Telescope |\r\n|        LAPALMA |                        Roque de los Muchachos, La Palma. |\r\n|            MSO |                                  Mt. Stromlo Observatory |\r\n|            SSO |                                Siding Spring Observatory |\r\n|            AAO |                             Anglo-Australian Observatory |\r\n|       MCDONALD |                                     McDonald Observatory |\r\n|            LCO |                                 Las Campanas Observatory |\r\n|      MTBIGELOW |                  Catalina Observatory: 61 inch telescope |\r\n|            DAO |                       Dominion Astrophysical Observatory |\r\n|            SPM |     Observatorio Astronomico Nacional, San Pedro Martir. |\r\n|           TONA |         Observatorio Astronomico Nacional, Tonantzintla. |\r\n|        PALOMAR |                                       The Hale Telescope |\r\n|            MDM |                       Michigan-Dartmouth-MIT Observatory |\r\n|            NOV |                        National Observatory of Venezuela |\r\n|            BMO |                              Black Moshannon Observatory |\r\n|            BAO |                             Beijing XingLong Observatory |\r\n|           KECK |                                   W. M. Keck Observatory |\r\n|           EKAR |                               Mt. Ekar 182 cm. Telescope |\r\n|            APO |                                 Apache Point Observatory |\r\n|         LOWELL |                                       Lowell Observatory |\r\n|            VBO |                                  Vainu Bappu Observatory |\r\n|            IAO |                   Indian Astronomical Observatory, Hanle |\r\n|           FLWO |                                      Whipple Observatory |\r\n|          FLWO1 |                                      Whipple Observatory |\r\n|            ORO |                                    Oak Ridge Observatory |\r\n|            LNA |             Laboratorio Nacional de Astrofisica - Brazil |\r\n|           SAAO |                   South African Astronomical Observatory |\r\n|         CASLEO |              Complejo Astronomico El Leoncito, San Juan. |\r\n|         BOSQUE |             Estacion Astrofisica Bosque Alegre, Cordoba. |\r\n|         ROZHEN |     National Astronomical Observatory Rozhen - Bulgaria. |\r\n|           IRTF |                         NASA Infrared Telescope Facility |\r\n|          BGSUO |                    Bowling Green State Univ Observatory. |\r\n|           DSAZ |     Deutsch-Spanisches Observatorium Calar Alto - Spain. |\r\n|             CA |                                   Calar Alto Observatory |\r\n|           HOLI |  Observatorium Hoher List (Universitaet Bonn) - Germany. |\r\n|            LMO |                            Leander McCormick Observatory |\r\n|            FMO |                                 Fan Mountain Observatory |\r\n|         WHITIN |                     Whitin Observatory,Wellesley College |\r\n|            OSN |                            Observatorio de Sierra Nevada |\r\n|   GEMINI NORTH |                                 Gemini North Observatory |\r\n|   GEMINI SOUTH |                                 Gemini South Observatory |\r\n|        LASILLA |                 European Southern Observatory: La Silla. |\r\n|        PARANAL |                  European Southern Observatory: Paranal. |\r\n|         ESONTT |            European Southern Observatory, NTT, La Silla. |\r\n|         ESO36M | European Southern Observatory, 3.6m Telescope, La Silla. |\r\n|         ESOVLT |             European Southern Observatory, VLT, Paranal. |\r\n|            SLN |                 SLN - Catania Astrophysical Observatory. |\r\n|            EUO |                               Ege University Observatory |\r\n|            TNO |                             Turkiye National Observatory |\r\n|            TUG |                    TUBITAK National Observatory, Turkey. |\r\n|            MGO |                                 Mount Graham Observatory |\r\n|          ARIES | Aryabhatta Research Institute of Observational Sciences. |\r\n|           OALP |                     Observatorio Astronomico de La Plata |\r\n|           OLIN |                   Connecticut College - Olin Observatory |\r\n|         BOYDEN |                                       Boyden Observatory |\r\n|          LULIN |                                        Lulin Observatory |\r\n|           SOAR |               Southern Astrophysical Research Telescope. |\r\n|          BAKER |                                        Baker Observatory |\r\n|            HET |           McDonald Observatory - Hobby-Eberly Telescope. |\r\n|           JCDO |        Jack C. Davis Observatory, Western Nevada College |\r\n|            LNO |                            Langkawi National Observatory |\r\n\r\n\r\n<br>\r\n##<a name=PlotLoc></a>[Plot](SLiPy/Plot.py)\r\n\r\nConvenient wrappers to matplotlib for plotting spectra. A *SPlot* simply\r\ncreates a handle to remember figure attributes, to quickly go from looking\r\nat one spectra to another. One can also *overlay* spectra.\r\n\r\n<a name=SPlotLoc></a>\r\n- class **SPlot** ( *spectrum*, \\*\\**kwargs* ):\r\n\r\n    Spectrum Plot - Create figure of *spectrum*.\r\n\r\n    | Options  | Defaults   | Descriptions         |\r\n    |----------|------------|----------------------|\r\n    | *marker* | 'b-'       | marker for data      |\r\n    | *label*  | 'spectrum' | name of object       |\r\n    | *usetex* | False      | render with pdflatex |\r\n\r\n    <br>\r\n    The following member functions call pyplot equivalent:  \r\n    **xlim**, **ylim**, **xlabel**, **ylabel**, **title**, **legend**,\r\n    **text**, **grid**, **close**.\r\n\r\n    Here, when these function are called, the arguments are passed to\r\n    matplotlib; however, these calls are remembered. So when you go to *draw*\r\n    the figure again, you are back where you left off.\r\n\r\n    - *draw*( ):\r\n\r\n        Rebuild and render the figure.\r\n\r\n    - *refresh*( ):\r\n\r\n        Re-render (refresh) the figure, without clearing the axis.\r\n\r\n    - *txtclear*( ):\r\n\r\n        Clear all the calls to *text*( ) from the figure.\r\n\r\n    - *xoffset*( *value* ):\r\n\r\n        Switch either on or off (*value* = True | False) the horizontal offset.\r\n\r\n    - *yoffset*( *value* ):\r\n\r\n        Switch either on or off (*value* = True | False) the vertical offset.\r\n\r\n    - *overlay*( \\**splots* ):\r\n\r\n        Given one or more *splots*, *overlay* the figures.\r\n\t\t\r\n\t- *markers*( \\**args* ):\r\n\t\r\n\t\tReassign the values for the `marker`s in the figure. The number\r\n\t\tof arguments must equal the number of spectra in the figure. This\r\n\t\tstarts out as one, but will increase for ever call to SPlot.overlay().\r\n\r\n    - *restore*( ):\r\n\r\n        Restore the figure to only the original spectrum.\r\n\r\n    - *save*( *filename* ):\r\n\r\n        Save the figure to a file called *filename*. The file format is derived\r\n        from the extention of *filename*.\r\n\r\n<a name=IterateLoc></a>\r\n- **Iterate**( \\**splots*, \\*\\**kwargs* ):\r\n\r\n\tIterate thru *splots* to inspect data, the user marks spectra of\r\n\tinterest. The function returns a list of *keepers*.\r\n\r\n    | Options | Defaults  | Descriptions          |\r\n    |---------|-----------|-----------------------|\r\n    | *keep*  | 'name'    | alternative is 'plot' |\r\n\r\n    <br>\r\n    **Example:**\r\n    ```python\r\n    from slipy import Fits, Plot\r\n\r\n    fpath = '?' # toplevel directory name where your FITS files are\r\n    files = Fits.Find(fpath)\r\n\r\n    spectra = Fits.GetData( *files )\r\n\r\n    figure = [\r\n\r\n        Plot.SPlot( spectrum, label=Fits.Header(fname, 'object') )\r\n        for spectrum, fname in zip(spectra, files)\r\n    ]\r\n\r\n    keepers = Plot.Iterate( *figure )\r\n    # enter either 'y', 'n', or 'x' as prompted by the terminal\r\n    ```\r\n\r\n\r\n<br>\r\n##<a name=ProfileLoc></a>[Profile](SLiPy/Profile.py)\r\n\r\nProfile fitting tasks for spectra.\r\n\r\n<a name=SelectLoc></a>\r\n- **Select** ( *splot* ):\r\n\r\n    Select points from the *splot*. This should be of type SPlot \r\n    (or it can optionally be a Spectrum type, for which a SPlot will be\r\n    created). The splot will be rendered and the user clicks on the \r\n    figure. When finished, return to the terminal prompt. A dictionary is\r\n    returned with two entries, *wave* and *data*, representing the x-y\r\n    locations selected by the user. This can always be retrieved later by\r\n    accessing the module member *Profile.selected*.\r\n\t\r\n\tWhile the user makes selections, temporary markers appear on the figure\r\n\tindicating the data point that was just selected. If a mark does not \r\n\tappear, try moving the curser slightly and trying again. Even if the line\r\n\tgoes through that point, there might not actually be data there.\r\n\r\n<a name=FitLoc></a>\r\n- **Fit** ( *splot*, *function* = InvertedLorentzian, *params* = None)\r\n\r\n    Given a *splot* of type Plot.SPlot, the user selects four points on the \r\n    spectrum and a parameterized function is fit (an inverted Lorentzian by\r\n    default). Optionally, *splot* can be of type spectrum and a basic SPlot\r\n    will be created for you. If the user gives an alternative *function*, \r\n    *params* (parameters) must be provided. *params* is to be the first guess, \r\n    *p0* given to scipy...curve_fit; the user can provide them expicitely, \r\n    or in the form of functions with the templates `f(x, y)`\r\n    where *x* and *y* are the *wave* and *data* arrays (respectively) extracted\r\n    between the two inner points selected by the user.\r\n\t\r\n\t*InvertedLorentian* is defined in SLiPy.Algorithms.Functions. The user does\r\n\tnot need to provide *params* for the default behavior.\r\n\t\r\n\t**Example:**\r\n\t```python\r\n\t# In this example I use an alternative function simply as an illustration.\r\n\t# I show the download, calibration, and fitting procedure involved ...\r\n\t\r\n\tfrom slipy import Fits, Simbad, Plot, Velocity, Telluric, Profile\r\n\tfrom slipy import Spectrum, Observatory, SlipyError, Units as u\r\n\tfrom slipy.Data import Elodie\r\n\t\r\n\t# See the Data package for more information about this section\r\n\tarchive = Elodie.Archive()\r\n\t\r\n\t# the one with highest S/N\r\n\tsci_file = archive.files['HD332329']\r\n\t\r\n\t# all files are in `data` member, first column is the file name \r\n\tcal_files = [ entry[0] for entry in archive.data['HD087901A'] ]\r\n\t\r\n\tElodie.Download(\r\n\t\t\tsci_file,                      # file name to download\r\n\t\t\tresample = (5850, 5950, 0.01), # pipeline command\r\n\t\t\toutpath = 'Science-Files'      # put under this directory\r\n\t\t)\r\n\t\t\r\n\tElodie.Download(\r\n\t\t\t*cal_files,                    # HD087901A is Regulus\r\n\t\t\tresample = (5850, 5950, 0.01), # pipeline command\r\n\t\t\toutpath = 'Calibration-Files'  # put under this directory\r\n\t\t)\r\n\t\r\n\tsci_file  = Fits.Find('Science-Files')[0]  # one file\r\n\tcal_files = Fits.Find('Calibration-Files') # six files (list)\r\n\t\r\n\tspectrum = Spectrum(sci_file)       # create spectrum object\r\n\tregulus  = Fits.GetData(*cal_files) # return list of spectrum objects\r\n\t\r\n\t# remove absorption due to Earth's atmosphere\r\n\tTelluric.Correct(spectrum, *regulus)\r\n\t\r\n\t# attach `ra`, `dec` and `jd` to spectrum for HelioCorrect()\r\n\t# Simbad returns values in units of decimal degrees\r\n\tra, dec = Simbad.Position('HD332329')\r\n\t\r\n\t# elements returned from Fits.Header() are unitless. Here we take\r\n\t# the MJD at beginning of exposure and solve for JD at middle of exposure\r\n\tMJD     = Fits.Header(sci_file, 'MJD-OBS')\r\n\tEXPTIME = Fits.Header(sci_file, 'EXPTIME')\r\n\tJD      = MJD + 2400000.5 + 0.5 * EXPTIME / 86400\r\n \r\n\t# attach to spectrum object as members\r\n\tspectrum.ra  = ra\r\n\tspectrum.dec = dec\r\n\tspectrum.jd  = JD * u.day\r\n \r\n\t# Elodie is at the Observatoire de Haute-Provence, France (OHP).\r\n\tVelocity.HelioCorrect( Observatory.OHP(), spectrum )\r\n \r\n\t# create figure\r\n\tfig = Plot.SPlot(spectrum, label='HD332329', marker='k-')\r\n\tfig.xlabel('Wavelength (Angstrom)', labelpad=20)\r\n\tfig.ylabel('Normalized Flux', labelpad=20)\r\n\tfig.xlim(5885, 5905)\r\n\tfig.legend(frameon=False)\r\n\t\r\n\t# Now we need to define some parameter functions to pass to Profile.Fit()\r\n\t# with our user function\r\n\tfrom slipy.Algorithms.Functions import InvertedGaussian\r\n \r\n\t# best guess for amplitude of gaussian\r\n\tdef A(x, y):\r\n\t\treturn 1 - y.min().value\r\n\t\r\n\t# best guess for mean of gaussian\r\n\tdef mu(x, y):\r\n\t\treturn x[ y.argmin() ].value\r\n\t\t\r\n\t# best guess for standard deviation of gaussian\r\n\tdef sigma(x, y):\r\n\t\treturn y.std().value\r\n\t\r\n\t# call the Profile.Fit() function with our user defined parameterization\r\n\tline = Profile.Fit(fig, function=InvertedGaussian, params=[A, mu, sigma])\r\n\t\r\n\t# Please select four points identifying the spectral line.\r\n\t# Outer points mark the domain of the line.\r\n\t# Inner points mark the sample of the line to fit.\r\n\t# Press <Return> after making your selections ...\r\n\t\r\n\t# now `line` is a Spectrum object generated by evaluating the \r\n\t# `InvertedGaussian` function on the larger domain selected by the\r\n\t# user with coefficients optimized using Profile.Fit().\r\n\t# You might use it to deblend this inner line with the overlapping ones.\r\n\t\r\n\t# save the figure ...\r\n\tfig.tight_layout()\r\n\tfig.xoffset(False)\r\n\tfig.refresh()\r\n\tfig.save('HD332329.png')\r\n\t```\r\n\t\r\n    ![example](Figures/Profile-Fit.png)\r\n\r\n    **Figure 2:** The above figure was generated by running the above code \r\n\tsnippet.\r\n\t\r\n<a name=ExtractLoc></a>\r\n- **Extract** ( *splot*, *kernel* = Gaussian, \\*\\**kwargs*):\r\n\r\n    Select locations in the *splot* figure, expected to be of type SPlot.\r\n    Exactly four points should be selected. These are used to extract a \r\n    line profile from the spectrum plotted in the splot figure. The inner\r\n    section is used for the line, and the outer intervals are used to model\r\n    the continuum; these, respectively, are both returned as Spectrum objects.\r\n    The gap is jumped using 1D interpolation (scipy...interp1d). In order\r\n\tto get a smooth continuum and error estimates, this function uses\r\n\tnon-parametric kernel regression (a.k.a. kernel smoothing) to fit a\r\n\tcurve through the data marked as continuum. Be default, the kernel\r\n\tfunction is the Gaussian. The user can actually use a different, user\r\n\tdefined kernel function, but it's template must match that of\r\n\tSLiPy.Algorithms.Functions.Gaussian. See the SLiPy.Algorithms.KernelFit\r\n\tmodule to better understand how this happens. The *bandwidth* is actually\r\n\tthe standard deviation in the Gaussian. It is a length scale that defines\r\n\thow influencial data is at a particular distance. The default bandwidth\r\n\twill almost definitely be too large (resulting in a largely flat result\r\n\tat the average of the data points). As the bandwidth decreases to smaller\r\n\tthan the resolution of the data, you will essentially being performing\r\n\tlinear interpolation (no smoothing). You want to choose a length that is\r\n\tlarger than the small scale variation in the noise, but smaller than the \r\n\tlarger scale variation in the overall continuum level.\r\n\t\r\n\tThe *rms* can optionally be computed between the continuum data and the \r\n\tcurve fit to it. This rms value is used to scale the error profile \r\n\tthat is returned for the line extracted. Explicitely, the error for a\r\n\tline extraction is `error_spectrum = continuum_rms * I_0 / I` where\r\n\t*I* is the line data and *I_0* is the interpolated continuum over the \r\n\tgap.\r\n\t\r\n\tFrom the documentation of scipy.interpolate...interp1d: *kind* specifies the \r\n\tkind of interpolation as a string ('linear', 'nearest', 'zero', 'slinear', \r\n\t'quadratic', 'cubic') where 'slinear', 'quadratic' and 'cubic' refer to a \r\n\tspline interpolation of first, second,  or third order respectively;  or as \r\n\tan integer specifying the order of the spline interpolator to use.\r\n\t\r\n    | Options      | Defaults   | Descriptions                            |\r\n    |--------------|------------|-----------------------------------------|\r\n    | *kind*       | 'cubic'    | given to scipy...interp1d for continuum |\r\n\t| *bandwidth*  | 0.1 * u.nm | for kernel, user should provide this!   |\r\n\t| *rms*        | False      | return an error estimate for the line   |\r\n\t\r\n\t<br>\r\n\t**Example:**\r\n\t```python\r\n\t# drawing from the previous example, but using HD200723 instead.\r\n\t\r\n\tline, continuum, rms = Profile.Extract(fig, bandwidth=u.Angstrom/15, rms=True)\r\n\t\r\n    # Please select four points identifying the spectral line.\r\n    # Outer intervals sample the continuum.\r\n    # Center interval contains the line.\r\n\t# Press <Return> after making your selections ...\r\n\t```\r\n\t\r\n    ![example](Figures/Profile-Extract.png)\r\n\r\n    **Figure 3:** The above figure was generated by running the above code \r\n\tsnippet.\r\n\t\r\n<br>\r\n##<a name=MontageLoc></a>[Montage](SLiPy/Montage.py)\r\n\r\n[Montage](http://montage.ipac.caltech.edu/) is a very powerful suite of C code\r\nfor creating image mosaics. This module is a wrapper to automate not only the\r\nprocess for small projects, but to segment large fields into a grid and\r\nmosaic each *site* before combining them into a *master* mosaic.\r\n\r\n<a name=MSolveGridLoc></a>\r\n- **SolveGrid** ( *sides*, *grid* ):\r\n\r\n\tHelper function for the Field and SubField classes. Both *sides* and *grid*\r\n\tneed to be array-like and of length two. *sides* is the side length of the\r\n\tfield in decimal degrees in right ascension and declination respectively.\r\n\t*grid* specifies the subdivision along these axis (e.g., (2,2) says 2x2).\r\n\r\n\tThe user should mindful of their choices. If the side lengths cannot be\r\n\tsubdivided into well-behaved (rational) segments, higher decimal places\r\n\twill be lost in the SubField.ArchiveList() task resulting in small\r\n\tgaps in the mosaic.\r\n\r\n<a name=MMosaicLoc></a>\r\n- **Mosaic** ( *resolution*, \\**folders*, \\*\\**kwargs* ):\r\n\r\n    Conduct standard build procedures for all *folders*, similar to the\r\n    [m101 example](http://montage.ipac.caltech.edu/docs/m101tutorial.html).\r\n    *resolution* is the number of pixels per degree for the output image.\r\n    Note: *folders* should be absolute paths. Further, below each of these\r\n    directories, there should already exist the standard folder structure\r\n    ```\r\n    folder/\r\n      |--images/\r\n      |    |-- <location of raw FITS images>\r\n      |\r\n      |--projected/\r\n      |--differences/\r\n      |--corrected/\r\n      |--final/\r\n    ```\r\n\r\n    <br>\r\n    The mosaic will be deposited at *final/mosaic.fits*.\r\n\r\n    | Options    | Defaults | Descriptions                             |\r\n    |------------|----------|------------------------------------------|\r\n    | *verbose*  | True     | display messages, progress               |\r\n    | *bkmodel*  | True     | model and correct for background effects |\r\n\r\n\r\n<a name=MSubFieldLoc></a>\r\n- class **SubField** ( *center*, *sides*, *grid*, \\*\\**kwargs* ):\r\n\r\n    Create a grid of *sites* each of which will be mosaiced separately and\r\n    then combined. Each of *center*, *sides*, and *grid* should be array-like\r\n    and of length two. *center* should be the very center location for the\r\n    mosaic in right ascension and declination (both in decimal degrees),\r\n    respectively. *sides* needs to give the side lengths of the desired\r\n    mosaic in decimal degrees (width-RA, height-DEC). *grid* should be the\r\n    grid division for the field (e.g., (2, 2) means 2x2 grid).\r\n\r\n    There will be a directory created for each *site* and also another *master*\r\n    directory. The final resulting mosaic will be deposited at\r\n    *final/mosaic.fits* here.\r\n\r\n    | Options   | Defaults | Descriptions                             |\r\n    |-----------|----------|------------------------------------------|\r\n    | *verbose* | True     | display messages, progress               |\r\n    | *survey*  | 'DSS'    | DSS, SDSS, 2MASS                         |\r\n    | *band*    | 'DSS2B'  | filter for *survey*, see *bands* dict    |\r\n    | *pad*     | 0.0      | amount to add (degrees) around *sites*   |\r\n\r\n    <br>\r\n    The available filter band for each survey are as follows\r\n\r\n    | Survey  | Bands                                                   |\r\n    |---------|---------------------------------------------------------|\r\n    | 'DSS'   | 'J', 'H', 'K'                                           |\r\n    | 'SDSS'  | 'U', 'G', 'R', 'I', 'Z'                                 |\r\n    | '2MASS' | 'DSS1B', 'DSS1R', 'DSS2B', 'DSS2R', 'DSS2IR', 'Quick-V' |\r\n\r\n    <br>\r\n    The user should execute the following available methods in this order:\r\n\r\n    - *ArchiveList* ( \\*\\**kwargs* ):\r\n\r\n        Run the `mArchiveList` command on the *site* grid. The only keyword\r\n        argument is *verbose* which defaults to True.\r\n\r\n    - *ArchiveExec* ( \\*\\**kwargs* ):\r\n\r\n        Run `mArchiveExec` on each *site* in the SubField. The only keyword\r\n        argument is *verbose* which defaults to True.\r\n\r\n    - *Build* ( *resolution*, \\*\\**kwargs*):\r\n\r\n        Run the build process for the *sites* in this SubField. See the\r\n        Montage.Mosaic() function documentation.\r\n\r\n    - *Collect* ( \\*\\**kwargs* ):\r\n\r\n        Collect the mosaics from all *site* locations into a master *images*\r\n        folder. The only keyword argument is *verbose* which defaults to True.\r\n\r\n    - *Merge* ( *resolution*, \\*\\**kwargs* ):\r\n\r\n        Merge all *site* mosaics into a single master SubField mosaic. We are\r\n        now calling Montage.Mosaic() on each *site*.\r\n\r\n    <br>\r\n    **Example:**\r\n    ```python\r\n    from slipy import Montage, Simbad\r\n\r\n    mosaic = Montage.SubField(\r\n\r\n        Simbad.Position('Pleiades'), # center of the Pleiades\r\n        (4, 4),                      # side lengths of mosaic\r\n        (2, 2)                       # grid pattern creates 2x2 degree `sites`\r\n    )\r\n\r\n    mosaic.ArchiveList()\r\n    mosaic.ArchiveExec()\r\n    mosaic.Build()\r\n    mosaic.Collect()\r\n    mosaic.Merge()\r\n\r\n    # If you have APLpy\r\n    import aplpy\r\n\r\n    fig = aplpy.FITSFigure('master/final/mosaic.fits')\r\n    fig.show_grayscale()\r\n\r\n    ```\r\n\r\n<a name=MFieldLoc></a>\r\n- class **Field** (*center*, *sides*, *grid*, *subgrid*, \\*\\**kwargs* ):\r\n\r\n    Large image mosaic manager for Montage. This class (in terms of its\r\n    usage) is the same as the *SubField* class, except that here we managing\r\n    the subfields. So all the member functions are the same name and purpose,\r\n    but instead act to call that same function on each subfield. Here, all\r\n    the constructor arguments are as before, with the additions of *subgrid*\r\n    which is also to be array-like of length two. *grid* will be the first\r\n    level division to find the centers and side lengths of all the subfields\r\n    and *subgrid* will be the further sub-division passed down to the daughter\r\n    subfields.\r\n\r\n    | Options   | Defaults | Descriptions                             |\r\n    |-----------|----------|------------------------------------------|\r\n    | *verbose* | True     | display messages, progress               |\r\n    | *survey*  | 'DSS'    | DSS, SDSS, 2MASS                         |\r\n    | *band*    | 'DSS2B'  | filter for *survey*, see *bands* dict    |\r\n    | *pad*     | 0.0      | amount to add (degrees) around *sites*   |\r\n\r\n    <br>\r\n    The available filter band for each survey are as follows\r\n\r\n    | Survey  | Bands                                                   |\r\n    |---------|---------------------------------------------------------|\r\n    | 'DSS'   | 'J', 'H', 'K'                                           |\r\n    | 'SDSS'  | 'U', 'G', 'R', 'I', 'Z'                                 |\r\n    | '2MASS' | 'DSS1B', 'DSS1R', 'DSS2B', 'DSS2R', 'DSS2IR', 'Quick-V' |\r\n\r\n    <br>\r\n    All the member functions are the same name as in *SubField*, but now with\r\n    the addition of a final step:\r\n\r\n    - *Finalize* ( *resolution*, \\*\\**kwargs* ):\r\n\r\n        Collect all SubField/master mosaics into a single folder and\r\n        run Mosaic() on them for a single final image.\r\n\r\n\r\n<br>\r\n##<a name=ElodieLoc></a>[Elodie](Data/Elodie.py)\r\n\r\nMethods for data retrieval from the Elodie Archive.\r\n\r\n<a name=EArchiveLoc></a>\r\n- class **Archive** ( \\*\\**kwargs* ):\r\n\r\n    Import and parse ascii catalog of Elodie archive files. The complete\r\n    archive is stored in the member dictionary, *data*. It's organized\r\n    by unique target names. Each target has a list of pairs consisting of the\r\n\tname of the file and the signal to noise for that spectrum. The reduced\r\n    archive by default contains only *HD*, *BD*, *HR*, *GC*, and *GJ* objects,\r\n    choosing the file pertaining to the spectra with the highest signal-to-noise\r\n    ratio available.\r\n\r\n    | Options    | Defaults                   | Descriptions          |\r\n    |------------|----------------------------|-----------------------|\r\n    | *infile*   | archives/elodie.csv        | path to input file    |\r\n    | *catalogs* | ['HD','BD','HR','GC','GJ'] | catalogs to keep      |\r\n\r\n    <br>\r\n    **Example:**\r\n    ```python\r\n    from slipy.Data import Elodie\r\n\r\n    archive = Elodie.Archive()\r\n\r\n    'HD187642' in archive.files # returns True (Altair)\r\n    'HD045348' in archive.files # returns False (Canopus)\r\n    ```\r\n\r\n<a name=EScriptLoc></a>\r\n- **Script** ( *filename*, *pipeline* = '' ):\r\n\r\n    Construct url script for Elodie archive given *filename* and optionally\r\n    *pipeline* instructions (e.g., '&z=wrs|fca[1,nor]').\r\n\r\n<a name=EDownloadLoc></a>\r\n- **Download** ( \\**files*, \\*\\**kwargs* ):\r\n\r\n    Download *files* from Elodie archive via url scripts. The spectra can be\r\n    further reduced via Elodie's pipeline with the following options.\r\n\r\n    | Options     | Defaults        | Descriptions                         |\r\n    |-------------|-----------------|--------------------------------------|\r\n    | *verbose*   | True            | display messages, progress           |\r\n    | *resample*  | (min, max, res) | resample spectra (no default)        |\r\n    | *normalize* | True            | continuum normalization              |\r\n    | *outpath*   | './'            | directory for downloaded *files*     |\r\n    | *names*     | []              | alternative output names for *files* |\r\n\r\n    <br>\r\n    **Example:**\r\n    ```python\r\n\t# continuing from the previous example ...\r\n\t\r\n    # all files in the archive for Altair (file name is first element in pair)\r\n    files = [ entry[0] for entry in archive.data['HD187642'] ]\r\n\r\n    # download files to current directory, resample spectrum to wavelengths\r\n    # between 5850 and 5950 with a resolution of 0.01 Angstroms per pixel\r\n    Elodie.Download( *files, resample=(5850, 5950, 0.01) )\r\n    ```\r\n","google":"UA-58405300-1","note":"Don't delete this file! It's used internally to help with page regeneration."}