<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>SLiPy by gLENTNER</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Ubuntu:300' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">SLiPy</h1>
      <h2 class="project-tagline">A Spectroscopy and astrophysics Library for Python 3</h2>
      <a href="https://github.com/gLENTNER/SLiPy" class="btn">View on GitHub</a>
      <a href="https://github.com/gLENTNER/SLiPy/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/gLENTNER/SLiPy/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="slipy" class="anchor" href="#slipy" aria-hidden="true"><span class="octicon octicon-link"></span></a><a href="http://glentner.github.io/SLiPy">SLiPy</a>
</h1>

<h4>
<a id="a-spectroscopy-and-astrophysics-library-for-python-3" class="anchor" href="#a-spectroscopy-and-astrophysics-library-for-python-3" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Spectroscopy and astrophysics Library for Python 3</h4>

<p>This Python package is an expanding code base for doing computational
astronomy, particularly spectroscopy. It contains both a <em>Spectrum</em> class
for handling spectra as objects (with +, -, *, /, etc... operations defined)
and a growing suite of analysis tools.</p>

<p><strong>Dependencies:</strong>
Python 3.x,
<a href="http://www.astropy.org">astropy</a>,
<a href="http://matplotlib.org">matplotlib</a>,
<a href="http://www.numpy.org">numpy</a>,
<a href="http://www.scipy.org">scipy</a></p>

<p><a href="http://www.astropy.org/"><img src="http://img.shields.io/badge/powered%20by-AstroPy-orange.svg?style=flat" alt="astropy"></a>
<a href="http://www.gnu.org/copyleft/gpl.html"><img src="http://img.shields.io/badge/license-GPLv3-blue.svg?style=flat" alt="GitHub license"></a></p>

<p>Quick note: the subpackage <strong>astrolibpy</strong> was not developed
by me. It was coded by Sergey Koposov (<a href="https://github.com/segasai" class="user-mention">@segasai</a>) at Cambridge (then at least).
I found it useful for performing velocity corrections on my spectroscopic
data. I've modified several modules such that it can be imported and used in
Python 3.x. See his README file.</p>

<h2>
<a id="contents" class="anchor" href="#contents" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contents</h2>

<p>SLiPy is split into several components. The principle component is the
subpackage <strong>SLiPy</strong> itself, which contains all the relevant
functionality. Further, <strong>Data</strong> is a package I'm working on that will provide
an API for searching astronomical data archives in a simple way. The other two
subpackages <strong>Framework</strong> and <strong>astrolibpy</strong> are of utility to the project but
not necessarily intended for export. As stated previously, astrolibpy was not
developed by me, only modified. I'm not going to document it's usage here. Its
name is unfortunate for me as it is a bit over done with the convention I was
already using, but for consistency I will keep it as it was from the author.</p>

<p>The following modules are elevated to the package level and are available
to import:</p>

<table>
<thead>
<tr>
<th>SLiPy/</th>
<th>Functions/Classes</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#SpectrumLoc"><strong>Spectrum</strong></a></td>
<td>
<a href="#WaveVectorLoc">WaveVector</a>, <a href="#SpectrumLoc">Spectrum</a>,</td>
</tr>
<tr>
<td><a href="#FitsLoc"><strong>Fits</strong></a></td>
<td>
<a href="#FindLoc">Find</a>, <a href="#RFindLoc">RFind</a>, <a href="#GetDataLoc">GetData</a>, <a href="#HeaderLoc">Header</a>, <a href="#SearchLoc">Search</a>, <a href="#PositionSortLoc">PositionSort</a>,</td>
</tr>
<tr>
<td><a href="#SimbadLoc"><strong>Simbad</strong></a></td>
<td>
<a href="#PositionLoc">Position</a>, <a href="#DistanceLoc">Distance</a>, <a href="#SptypeLoc">Sptype</a>, <a href="#IDListLoc">IDList</a>,</td>
</tr>
<tr>
<td><a href="#CorrelateLoc"><strong>Correlate</strong></a></td>
<td>
<a href="#XCorrLoc">XCorr</a>,</td>
</tr>
<tr>
<td><a href="#TelluricLoc"><strong>Telluric</strong></a></td>
<td>
<a href="#CorrectLoc">Correct</a>,</td>
</tr>
<tr>
<td><a href="#VelocityLoc"><strong>Velocity</strong></a></td>
<td>
<a href="#HelioCorrectLoc">HelioCorrect</a>, <a href="#BaryCorrectLoc">BaryCorrect</a>, <a href="#IrafInputLoc">IrafInput</a>,</td>
</tr>
<tr>
<td><a href="#ObservatoryLoc"><strong>Observatory</strong></a></td>
<td>
<a href="#OHPLoc">...</a>,</td>
</tr>
<tr>
<td><a href="#PlotLoc"><strong>Plot</strong></a></td>
<td>
<a href="#SPlotLoc">SPlot</a>, <a href="#IterateLoc">Iterate</a>,</td>
</tr>
<tr>
<td><a href="#ProfileLoc"><strong>Profile</strong></a></td>
<td>
<a href="#SelectLoc">Select</a>, <a href="#FitLoc">Fit</a>, <a href="#ExtractLoc">Extract</a>,</td>
</tr>
<tr>
<td><a href="#MontageLoc"><strong>Montage</strong></a></td>
<td>
<a href="#MSolveGridLoc">SolveGrid</a>, <a href="#MMosaicLoc">Mosaic</a>, <a href="#MSubFieldLoc">SubField</a>, <a href="#MFieldLoc">Field</a>,</td>
</tr>
</tbody>
</table>

<p><br></p>

<table>
<thead>
<tr>
<th>SLiPy/Data</th>
<th>Functions/Classes</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#ElodieLoc"><strong>Elodie</strong></a></td>
<td>
<a href="#EArchiveLoc">Archive</a>, <a href="#EScriptLoc">Script</a>, <a href="#EDownloadLoc">Download</a>,</td>
</tr>
</tbody>
</table>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>To install SLiPy, there is no setup procedure. Simply download the package,
either by clicking on the download link for a <em>tar</em> or <em>zip</em> archive or by
cloning it.</p>

<p>Extract it's contents to wherever you like in a directory (ostensibly named
<em>slipy</em>, but actually you can call this library whatever you want as well
because all the imports are <em>relative</em>). Then add the parent directory to your
<em>PYTHONPATH</em> if it isn't already. For example:</p>

<pre><code>$ cd
$ git clone http://github.com/glentner/slipy
$ echo "export PYTHONPATH=$PYTHONPATH:~" &gt;&gt; ~/.bashrc
</code></pre>

<p>And your ready to go!</p>

<h2>
<a id="exceptions" class="anchor" href="#exceptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exceptions</h2>

<p>SLiPy attempts to catch all foreseeable exceptions and re-throw them under a
common handle with a human readable message. There is a unique exception class
for every module, all derived from a common <em>SlipyError</em>. The naming convention 
is for a module's exception to be named after the module with the addition of 
the word <em>Error</em>. So the <em>Fits</em> module will throw a <em>FitsError</em>. These are meant
to handle erros internally. The user need not worry about these in an 
interactive session; however, inside of scipts you might catch <em>SlipyError</em>.
For finer control, catch the individual exceptions (e.g., <em>Fits.FitsError</em>).</p>

<h2>
<a id="contribute" class="anchor" href="#contribute" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contribute</h2>

<p>If you use SLiPy or have your own code related to spectroscopy or computing
for astronomy and think it would be a useful addition (or you find a
bug/mistake) I'm more than open to suggested contributions/additions.</p>

<h2>
<a id="authors" class="anchor" href="#authors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Author(s)</h2>

<p><a href="http://glentner.github.io">Geoffrey Lentner</a>, B.S.<br>
Graduate Research Assistant<br>
Department of Physics &amp; Astronomy<br>
University of Louisville</p>

<p>Significant intellectual contributions have been made by my thesis advisor,
specifically in terms of the science behind much of this package.</p>

<p><a href="http://www.physics.louisville.edu/jtl/">James Lauroesch</a>, Ph.D.<br>
Associate Professor<br>
Department of Physics &amp; Astronomy<br>
University of Louisville</p>

<h2>
<a id="acknowledge-slipy" class="anchor" href="#acknowledge-slipy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Acknowledge SLiPy</h2>

<p>If you have made use of SLiPy in your project/research, you can acknowledge
your use in the following ways:</p>

<p><strong>Publications</strong><br>
This research has made use of SLiPy, an open source spectroscopy and
astrophysics library for Python 3 (G. Lentner, 2015).</p>

<p><strong>Projects</strong><br>
If your code either makes use of or borrows from SLiPy, a good way to reference
this is with a <a href="http://shields.io">shield</a> in your README file.</p>

<p><a href="http://glentner.github.io/SLiPy"><img src="http://img.shields.io/badge/running-SLiPy-green.svg?style=flat" alt="SLiPy"></a></p>

<p>The above badge is generated using the following snippet</p>

<pre><code>[![SLiPy](http://img.shields.io/badge/running-SLiPy-green.svg?style=flat)](http://glentner.github.io/SLiPy)
</code></pre>

<h1>
<a id="documentation" class="anchor" href="#documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Documentation</h1>

<p><br></p>

<h2>
<a id="spectrum" class="anchor" href="#spectrum" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="SpectrumLoc"></a><a href="SLiPy/Spectrum.py">Spectrum</a>
</h2>

<p>Objects for representing astronomical data. Currently, this includes the
<em>Spectrum</em> class and it's helper function <em>WaveVector</em>.</p>

<p><a name="WaveVectorLoc"></a></p>

<ul>
<li>
<p><strong>WaveVector</strong> ( <em>rpix</em>, <em>rval</em>, <em>delt</em>, <em>npix</em> ):</p>

<p>Construct numpy array of wavelength values where <em>rpix</em> is the reference
pixel index, <em>rval</em> is the wavelength at reference pixel, <em>delt</em> is the
resolutions (delta lambda), and <em>npix</em> is the length of desired array.</p>
</li>
</ul>

<p><a name="SpectrumLoc"></a></p>

<ul>
<li>
<p>class <strong>Spectrum</strong> ( *<em>args</em>, **<em>kwargs</em> ):</p>

<p>The Spectrum object is a container class for a data array and its
corresponding wavelength array.</p>

<p>There are a few ways to create a Spectrum. If a single string 
argument is given, it is taken as a file name and used to read in
data from a FITS file. With the keyword argument <em>wavecal</em> set as
True (the default case), elements are read from the header to create
a corresponding wavelength array to go with the data.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>wavecal</em></td>
<td>True</td>
<td>fit wavelength vector to data</td>
</tr>
<tr>
<td><em>crpix1</em></td>
<td>'crpix1'</td>
<td>reference pixel header keyword</td>
</tr>
<tr>
<td><em>crval1</em></td>
<td>'crval1'</td>
<td>value at reference pixel</td>
</tr>
<tr>
<td><em>cdelt1</em></td>
<td>'cdelt1'</td>
<td>resolution (delta lambda)</td>
</tr>
<tr>
<td><em>xunits</em></td>
<td>'Angstrom'</td>
<td>units for wavelength array</td>
</tr>
<tr>
<td><em>yunits</em></td>
<td>''</td>
<td>units for data array</td>
</tr>
</tbody>
</table>

<p><br>
If an array-like object is given, it is converted to a numpy array and
taken as the spectrum data. A wavelength array will be generated that 
is simply an index (pixel) count. But if a second argument is provided, 
it will serve as the wavelength array. These must be equal in length 
however.</p>

<p>Units will be imposed for these arrays. When initialized from a file,
the default units are <em>Angstrom</em> and <em>dimensionless_unscaled</em> for the
wavelength and data arrays respectively. Alternatives can be applied
by providing the keyword arguments <em>xunits</em> and <em>yunits</em>. If 
initialized via an array-like object, <em>dimensionless_unscaled</em> will
only be applied if no units are detected. If no wavelength array is
provided, the generated wavelength array will have <em>pixel</em> units.
Units are again only applied if none are detected for the given array.</p>

<p>Addition, subtraction, multiplication, and division (including in-place 
operations, e.g., '+=') are defined for both spectrum on spectrum 
operations as well as scalar operations. When two spectra are operated on, 
the LHS spectrum takes precedent. One of the spectra must be contained 
within the other (i.e., their wavelength domain is either equal to or 
entirely interior to the other). The outer spectrum is resampled onto the 
inner spectrum's pixel space and the operation is applied element-wise. 
To state it briefly, only the affected region of the LHS spectrum is 
operated on. This makes units dangerous for multiplication and division.
Only in the case of multiplying/dividing spectra of equivilent wavelength
arrays will the units be properly applied. Otherwise, the RHS units will
be ignored. Considering the physical context within which it makes sense
to apply these operations to spectra this is justified; the data will have
<code>dimensionless</code> units in all likelihood. For scalar addition and 
subtraction, if no units are given the units are implied to be the same as
that of the data.</p>

<p>The comparison operations ( &gt;, &lt;, &gt;=, &lt;=, ==, !=, &amp;, ^, | ) are defined
to return a binary Spectrum of dimensionless 1's and 0's. The same 
convention applies as above. Either the LHS or RHS must be contained within 
the other, and the LHS is compared on the overlapping regions. Data outside 
this overlapping region is returned as False.</p>

<p>The shift operations ('&gt;&gt;' and '&lt;&lt;') are defined to mean a shift in the
spectrum. The addition and subtraction operate on the <em>data</em>. These
operations apply to the <em>wave</em> array. <code>Spectrum &lt;&lt; 2 * u.Angstrom</code> says
to blue shift the spectrum by 2 Angstroms. If the RHS is a dimensionless
number, the wavelength units are implied. Also, one can shift a spectrum
by another spectrum (e.g., <code>spectrumA &gt;&gt; spectrumB</code>), where the <em>wave</em> 
arrays would be operated on only. In these cases, they should
have the same number of pixels! Finally, to get a variable shift across
the spectrum without creating a whole spectrum with junk data, you can
shift using a numpy array (also of equal length). If no units are detected,
the wavelength units will be implied.</p>

<p>Other operations:</p>

<div class="highlight highlight-python"><pre><span class="pl-c"># The wavelength domain of A is either equal to or contained by B. </span>
<span class="pl-c"># Returns True or False</span>
SpectrumA <span class="pl-k">in</span> SpectrumB </pre></div>

<div class="highlight highlight-python"><pre><span class="pl-c"># Returns number of pixels</span>
<span class="pl-c1">len</span>(Spectrum) </pre></div>

<div class="highlight highlight-python"><pre><span class="pl-c"># Calls str() on member arrays, (e.g., print(Spectrum))</span>
<span class="pl-c1">str</span>(Spectrum) </pre></div>

<p>Also, you can access the spectrum data via "index" notation. The behavior
is not the same though. See the below interactive demonstration.</p>

<div class="highlight highlight-python"><pre>In [<span class="pl-c1">1</span>]: <span class="pl-k">from</span> slipy <span class="pl-k">import</span> Spectrum \
   ...: <span class="pl-k">from</span> astropy <span class="pl-k">import</span> units <span class="pl-k">as</span> u \
   ...: <span class="pl-k">import</span> numpy <span class="pl-k">as</span> np

In [<span class="pl-c1">2</span>]: x <span class="pl-k">=</span> np.linspace(<span class="pl-k">-</span><span class="pl-c1">2</span><span class="pl-k">*</span>np.pi, <span class="pl-c1">2</span><span class="pl-k">*</span>np.pi, <span class="pl-c1">25</span>) <span class="pl-c"># -2pi &lt; x &lt; 2pi</span>

In [<span class="pl-c1">3</span>]: y <span class="pl-k">=</span> np.sin( np.pi <span class="pl-k">*</span> x ) <span class="pl-k">/</span> (np.pi <span class="pl-k">*</span> x)   <span class="pl-c"># sinc(pi x)</span>

In [<span class="pl-c1">4</span>]: s <span class="pl-k">=</span> Spectrum(y)

In [<span class="pl-c1">5</span>]: <span class="pl-c"># display spectrum \</span>
   ...: s
Out[<span class="pl-c1">5</span>]:
[ <span class="pl-c1">0.03935584</span> <span class="pl-k">-</span><span class="pl-c1">0.05252603</span>  <span class="pl-c1">0.00796074</span>  <span class="pl-c1">0.0597675</span>  <span class="pl-k">-</span><span class="pl-c1">0.07945138</span>  <span class="pl-c1">0.0079739</span>
  <span class="pl-c1">0.11489588</span> <span class="pl-k">-</span><span class="pl-c1">0.17056501</span>  <span class="pl-c1">0.00798048</span>  <span class="pl-c1">0.82957457</span>  <span class="pl-c1">0.82957457</span>  <span class="pl-c1">0.00798048</span>
 <span class="pl-k">-</span><span class="pl-c1">0.17056501</span>  <span class="pl-c1">0.11489588</span>  <span class="pl-c1">0.0079739</span>  <span class="pl-k">-</span><span class="pl-c1">0.07945138</span>  <span class="pl-c1">0.0597675</span>   <span class="pl-c1">0.00796074</span>
 <span class="pl-k">-</span><span class="pl-c1">0.05252603</span>  <span class="pl-c1">0.03935584</span>]
[  <span class="pl-c1">1.</span>   <span class="pl-c1">2.</span>   <span class="pl-c1">3.</span>   <span class="pl-c1">4.</span>   <span class="pl-c1">5.</span>   <span class="pl-c1">6.</span>   <span class="pl-c1">7.</span>   <span class="pl-c1">8.</span>   <span class="pl-c1">9.</span>  <span class="pl-c1">10.</span>  <span class="pl-c1">11.</span>  <span class="pl-c1">12.</span>  <span class="pl-c1">13.</span>  <span class="pl-c1">14.</span>  <span class="pl-c1">15.</span>
  <span class="pl-c1">16.</span>  <span class="pl-c1">17.</span>  <span class="pl-c1">18.</span>  <span class="pl-c1">19.</span>  <span class="pl-c1">20.</span>] pix

In [<span class="pl-c1">9</span>]: <span class="pl-c"># where no units are given, they are implied. \</span>
   ...: s[<span class="pl-c1">2</span>]
Out[<span class="pl-c1">9</span>]: <span class="pl-k">&lt;</span>Quantity <span class="pl-k">-</span><span class="pl-c1">0.05252602557386098</span><span class="pl-k">&gt;</span>

In [<span class="pl-c1">10</span>]: <span class="pl-c"># that was not the second element of the spectrum, but the signal \</span>
   ....: <span class="pl-c"># at the location `2 pix`. Accessing the spectrum where it is not \</span>
   ....: <span class="pl-c"># defined returns a linear approximation to it between the two \</span>
   ....: <span class="pl-c"># pixels that surround it. \</span>
   ....: s[<span class="pl-c1">2.5</span>]
Out[<span class="pl-c1">10</span>]: <span class="pl-k">&lt;</span>Quantity <span class="pl-k">-</span><span class="pl-c1">0.02228264076183217</span><span class="pl-k">&gt;</span>

In [<span class="pl-c1">11</span>]: <span class="pl-c"># units are an acceptable access method, so long as they can be \</span>
   ....: <span class="pl-c"># converted (e.g., u.nm -&gt; u.Angstrom) \</span>
   ....: s[<span class="pl-c1">2.5</span> <span class="pl-k">*</span> u.pixel]
Out[<span class="pl-c1">11</span>]: <span class="pl-k">&lt;</span>Quantity <span class="pl-k">-</span><span class="pl-c1">0.02228264076183217</span><span class="pl-k">&gt;</span>

In [<span class="pl-c1">12</span>]: <span class="pl-c"># Slicing the spectrum works in two ways. If no `step` is given \</span>
   ....: <span class="pl-c"># than the `start` and `stop` act as a domain for which we \</span>
   ....: <span class="pl-c"># want to truncate the spectrum outside of. \</span>
   ....: s[<span class="pl-c1">2</span>:<span class="pl-c1">4</span>]
Out[<span class="pl-c1">12</span>]: 
[<span class="pl-k">-</span><span class="pl-c1">0.05252603</span>  <span class="pl-c1">0.00796074</span>  <span class="pl-c1">0.0597675</span> ]
[ <span class="pl-c1">2.</span>  <span class="pl-c1">3.</span>  <span class="pl-c1">4.</span>] pix

In [<span class="pl-c1">13</span>]: s[<span class="pl-c1">2.5</span>:<span class="pl-c1">4.5</span>]
Out[<span class="pl-c1">13</span>]: 
[ <span class="pl-c1">0.00796074</span>  <span class="pl-c1">0.0597675</span> ]
[ <span class="pl-c1">3.</span>  <span class="pl-c1">4.</span>] pix

In [<span class="pl-c1">14</span>]: s[:<span class="pl-c1">4</span>]
Out[<span class="pl-c1">14</span>]: 
[ <span class="pl-c1">0.03935584</span> <span class="pl-k">-</span><span class="pl-c1">0.05252603</span>  <span class="pl-c1">0.00796074</span>  <span class="pl-c1">0.0597675</span> ]
[ <span class="pl-c1">1.</span>  <span class="pl-c1">2.</span>  <span class="pl-c1">3.</span>  <span class="pl-c1">4.</span>] pix

In [<span class="pl-c1">15</span>]: s[<span class="pl-c1">15</span>:]
Out[<span class="pl-c1">15</span>]: 
[ <span class="pl-c1">0.0079739</span>  <span class="pl-k">-</span><span class="pl-c1">0.07945138</span>  <span class="pl-c1">0.0597675</span>   <span class="pl-c1">0.00796074</span> <span class="pl-k">-</span><span class="pl-c1">0.05252603</span>  <span class="pl-c1">0.03935584</span>]
[ <span class="pl-c1">15.</span>  <span class="pl-c1">16.</span>  <span class="pl-c1">17.</span>  <span class="pl-c1">18.</span>  <span class="pl-c1">19.</span>  <span class="pl-c1">20.</span>] pix

In [<span class="pl-c1">16</span>]: <span class="pl-c"># With a `step` size the behavior is entirely different. \</span>
   ....: <span class="pl-c"># We are asking instead to `resample` the spectrum. The  \</span>
   ....: <span class="pl-c"># `step` value acts as a desired resolution. As with the \</span>
   ....: <span class="pl-c"># accessor methods, the gaps are filled with linear      \</span>
   ....: <span class="pl-c"># approximations \</span>
   ....: s[<span class="pl-c1">1</span>:<span class="pl-c1">3</span>:<span class="pl-c1">0.5</span>]
Out[<span class="pl-c1">16</span>]: 
[ <span class="pl-c1">0.03935584</span> <span class="pl-k">-</span><span class="pl-c1">0.00658509</span> <span class="pl-k">-</span><span class="pl-c1">0.05252603</span> <span class="pl-k">-</span><span class="pl-c1">0.02228264</span>  <span class="pl-c1">0.00796074</span>]
[ <span class="pl-c1">1.</span>   <span class="pl-c1">1.5</span>  <span class="pl-c1">2.</span>   <span class="pl-c1">2.5</span>  <span class="pl-c1">3.</span> ] pix

In [<span class="pl-c1">17</span>]: s <span class="pl-k">=</span> s[:<span class="pl-c1">4</span>] \
   ....: s
Out[<span class="pl-c1">17</span>]: 
[ <span class="pl-c1">0.03935584</span> <span class="pl-k">-</span><span class="pl-c1">0.05252603</span>  <span class="pl-c1">0.00796074</span>  <span class="pl-c1">0.0597675</span> ]
[ <span class="pl-c1">1.</span>  <span class="pl-c1">2.</span>  <span class="pl-c1">3.</span>  <span class="pl-c1">4.</span>] pix

In [<span class="pl-c1">18</span>]: <span class="pl-c"># Without a `start` and a `stop` we just resample. \</span>
   ....: s[::<span class="pl-c1">0.5</span>]
Out[<span class="pl-c1">18</span>]: 
[ <span class="pl-c1">0.03935584</span> <span class="pl-k">-</span><span class="pl-c1">0.00658509</span> <span class="pl-k">-</span><span class="pl-c1">0.05252603</span> <span class="pl-k">-</span><span class="pl-c1">0.02228264</span>  <span class="pl-c1">0.00796074</span>  <span class="pl-c1">0.03386412</span>
  <span class="pl-c1">0.0597675</span> ]
[ <span class="pl-c1">1.</span>   <span class="pl-c1">1.5</span>  <span class="pl-c1">2.</span>   <span class="pl-c1">2.5</span>  <span class="pl-c1">3.</span>   <span class="pl-c1">3.5</span>  <span class="pl-c1">4.</span> ] pix

In [<span class="pl-c1">19</span>]: s <span class="pl-k">=</span> Spectrum(y) \
   ....: s
Out[<span class="pl-c1">19</span>]: 
[ <span class="pl-c1">0.03935584</span> <span class="pl-k">-</span><span class="pl-c1">0.05252603</span>  <span class="pl-c1">0.00796074</span>  <span class="pl-c1">0.0597675</span>  <span class="pl-k">-</span><span class="pl-c1">0.07945138</span>  <span class="pl-c1">0.0079739</span>
  <span class="pl-c1">0.11489588</span> <span class="pl-k">-</span><span class="pl-c1">0.17056501</span>  <span class="pl-c1">0.00798048</span>  <span class="pl-c1">0.82957457</span>  <span class="pl-c1">0.82957457</span>  <span class="pl-c1">0.00798048</span>
 <span class="pl-k">-</span><span class="pl-c1">0.17056501</span>  <span class="pl-c1">0.11489588</span>  <span class="pl-c1">0.0079739</span>  <span class="pl-k">-</span><span class="pl-c1">0.07945138</span>  <span class="pl-c1">0.0597675</span>   <span class="pl-c1">0.00796074</span>
 <span class="pl-k">-</span><span class="pl-c1">0.05252603</span>  <span class="pl-c1">0.03935584</span>]
[  <span class="pl-c1">1.</span>   <span class="pl-c1">2.</span>   <span class="pl-c1">3.</span>   <span class="pl-c1">4.</span>   <span class="pl-c1">5.</span>   <span class="pl-c1">6.</span>   <span class="pl-c1">7.</span>   <span class="pl-c1">8.</span>   <span class="pl-c1">9.</span>  <span class="pl-c1">10.</span>  <span class="pl-c1">11.</span>  <span class="pl-c1">12.</span>  <span class="pl-c1">13.</span>  <span class="pl-c1">14.</span>  <span class="pl-c1">15.</span>
  <span class="pl-c1">16.</span>  <span class="pl-c1">17.</span>  <span class="pl-c1">18.</span>  <span class="pl-c1">19.</span>  <span class="pl-c1">20.</span>] pix

In [<span class="pl-c1">20</span>]: <span class="pl-c"># The boundaries take precident however, and not every resolution \</span>
   ....: <span class="pl-c"># makes physical sense with the requested boundaries. When no     \</span>
   ....: <span class="pl-c"># edges are specified, they default to the current boundaries.    \</span>
   ....: <span class="pl-c"># There are only 19 pixels, so we won't get what you might think  \</span>
   ....: <span class="pl-c"># the expected behavior is. Here, 5 doesn't go evenly into the    \</span>
   ....: <span class="pl-c"># existing domain, so we simply choose the closest thing.</span>
   ....: s[::<span class="pl-c1">5</span>]
Out[<span class="pl-c1">20</span>]: 
[ <span class="pl-c1">0.03935584</span>  <span class="pl-c1">0.01974225</span>  <span class="pl-c1">0.01974225</span>  <span class="pl-c1">0.03935584</span>]
[  <span class="pl-c1">1.</span>           <span class="pl-c1">7.33333333</span>  <span class="pl-c1">13.66666667</span>  <span class="pl-c1">20.</span>        ] pix
</pre></div>

<p><br>
Member functions:</p>

<ul>
<li>
<p><em>resample</em> ( *<em>args</em>, <em>kind</em> = 'linear' ):</p>

<p>If given a single argument, it is taken to be a <em>Spectrum</em> object,
and <em>self</em> is resampled onto the pixel space of the other spectrum.
Otherwise, three arguments are expected. The first and second argument
should define the lower and upper wavelength value of a domain,
respectively. The third argument should be the number of elements
(pixels) for the new domain. Think numpy.linspace(). <em>kind</em> is passed
to scipy...interp1d.</p>

<div class="highlight highlight-python"><pre>spectrumA.resample(spectrumB, <span class="pl-smi">kind</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>cubic<span class="pl-pds">'</span></span>)

spectrumA.resample( <span class="pl-c1">585</span> <span class="pl-k">*</span> u.nm, <span class="pl-c1">5950</span> <span class="pl-k">*</span> u.Angstrom, <span class="pl-c1">1e4</span> <span class="pl-k">+</span> <span class="pl-c1">1</span> )</pre></div>
</li>
<li>
<p><em>insert</em> ( <em>other</em>, <em>kind</em> = 'linear'):</p>

<p>Given a Spectrum, <em>other</em>, contained within the wavelength domain
of <em>self</em>, replace all pixels in the overlapping region with that
of an interpolation built on <em>other</em>. <em>kind</em> is passed to interp1d.</p>

<div class="highlight highlight-python"><pre>spectrumA.insert(spectrumB, <span class="pl-smi">kind</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>quadratic<span class="pl-pds">'</span></span>)</pre></div>
</li>
<li>
<p><em>copy</em> ():</p>

<p>Essentially a wrapper to <em>deepcopy()</em>. To say SpectrumA = SpectrumB
implies that SpectrumA <em>is</em> SpectrumB. If you want to create a new
spectrum <em>equal</em> to another, say SpectrumA = SpectrumB.copy()</p>
</li>
</ul>
</li>
</ul>

<p><br></p>

<h2>
<a id="fits" class="anchor" href="#fits" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="FitsLoc"></a><a href="SLiPy/Fits.py">Fits</a>
</h2>

<p>Manipulate FITS files. Import data into <em>Spectrum</em> objects. Filter results
by right ascension and declination. Grab header elements. Search for attributes
of the data such as distance, spectral type, etc.</p>

<p><a name="FindLoc"></a></p>

<ul>
<li>
<p><strong>Find</strong> (<em>toplevel</em> = './', <em>pattern</em> = '*.fits'):</p>

<p>Search for file paths below <em>toplevel</em> fitting <em>pattern</em>. Returns a list
of string values.</p>
</li>
</ul>

<p><a name="RFindLoc"></a></p>

<ul>
<li>
<p><strong>RFind</strong> (<em>toplevel</em> = './', <em>pattern</em> = '*.fits'):</p>

<p>Recursively search for file paths below <em>toplevel</em> fitting <em>pattern</em>.
Returns a list of string values.</p>
</li>
</ul>

<p><a name="GetDataLoc"></a></p>

<ul>
<li>
<p><strong>GetData</strong> ( *<em>files</em>, **<em>kwargs</em>):</p>

<p>Import data from FITS <em>files</em>. Returns a list of <em>Spectrum</em> objects.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>verbose</em></td>
<td>True</td>
<td>display messages, progress</td>
</tr>
<tr>
<td><em>toplevel</em></td>
<td>''</td>
<td>request import from directory <em>toplevel</em>
</td>
</tr>
<tr>
<td><em>pattern</em></td>
<td>'*.fits'</td>
<td>pattern matching with <em>toplevel</em>
</td>
</tr>
<tr>
<td><em>recursive</em></td>
<td>False</td>
<td>search recursively below <em>toplevel</em>
</td>
</tr>
<tr>
<td><em>wavecal</em></td>
<td>True</td>
<td>fit wavelength vector to data</td>
</tr>
<tr>
<td><em>crpix1</em></td>
<td>'crpix1'</td>
<td>reference pixel header keyword</td>
</tr>
<tr>
<td><em>crval1</em></td>
<td>'crval1'</td>
<td>value at reference pixel</td>
</tr>
<tr>
<td><em>cdelt1</em></td>
<td>'cdelt1'</td>
<td>resolution (delta lambda)</td>
</tr>
<tr>
<td><em>xunits</em></td>
<td>'Angstrom'</td>
<td>wavelength units (astropy.units)</td>
</tr>
<tr>
<td><em>yunits</em></td>
<td>'ergs cm-2 s-1'</td>
<td>units of the data</td>
</tr>
</tbody>
</table>
</li>
</ul>

<p><a name="HeaderLoc"></a></p>

<ul>
<li>
<p><strong>Header</strong> ( <em>filename</em>, <em>keyword</em> = None, **<em>kwargs</em>):</p>

<p>Retrieve <em>keyword</em> from FITS header in file <em>filename</em>.
Return type depends on what is returned. If no keyword is
given, the entire header object is returned.</p>
</li>
</ul>

<p><a name="SearchLoc"></a></p>

<ul>
<li>
<p><strong>Search</strong> ( *<em>files</em>, **<em>kwargs</em>):</p>

<p>Extract object names from Fits <em>files</em> and use Simbad module
to resolve the <em>attribute</em> (a required keyword argument)
from the SIMBAD astronomical database. Currently available attributes
are 'Position', 'Distance', 'Sptype', and 'IDList'. Returns a list of
results (type depends on the values).</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>verbose</em></td>
<td>True</td>
<td>display messages, progress</td>
</tr>
<tr>
<td><em>toplevel</em></td>
<td>None</td>
<td>search under <em>toplevel</em> directory</td>
</tr>
<tr>
<td><em>pattern</em></td>
<td>'*.fits'</td>
<td>for files under <em>toplevel</em>
</td>
</tr>
<tr>
<td><em>recursive</em></td>
<td>False</td>
<td>search recusively under <em>toplevel</em>
</td>
</tr>
<tr>
<td><em>attribute</em></td>
<td>None</td>
<td>attribute to search for (no default)</td>
</tr>
</tbody>
</table>
</li>
</ul>

<p><a name="PositionSortLoc"></a></p>

<ul>
<li>
<p><strong>PositionSort</strong> ( <em>center</em>, <em>radius</em>, *<em>files</em>, **<em>kwargs</em> ):</p>

<p>Return a list of files from <em>files</em> that lie in a <em>radius</em> (in
decimal degrees) from <em>center</em>, based on the <em>ra</em> (right ascension) and
<em>dec</em> (declination).</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>ra</em></td>
<td>'pos1'</td>
<td>header element for right ascension</td>
</tr>
<tr>
<td><em>dec</em></td>
<td>'pos2'</td>
<td>header element for declination</td>
</tr>
<tr>
<td><em>obj</em></td>
<td>'object'</td>
<td>header element for object id</td>
</tr>
<tr>
<td><em>raconvert</em></td>
<td>True</td>
<td>convert decimal hours to decimal degrees</td>
</tr>
<tr>
<td><em>verbose</em></td>
<td>True</td>
<td>display messages, progress</td>
</tr>
<tr>
<td><em>toplevel</em></td>
<td>None</td>
<td>
<em>toplevel</em> directory to look for files</td>
</tr>
<tr>
<td><em>recursive</em></td>
<td>False</td>
<td>search below <em>toplevel</em> recursively</td>
</tr>
<tr>
<td><em>pattern</em></td>
<td>'*.fits'</td>
<td>glob <em>pattern</em> for file search</td>
</tr>
<tr>
<td><em>useSimbad</em></td>
<td>False</td>
<td>use <em>Simbad</em> instead of header elements</td>
</tr>
</tbody>
</table>
</li>
</ul>

<p><br></p>

<h2>
<a id="simbad" class="anchor" href="#simbad" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="SimbadLoc"></a><a href="SLiPy/Simbad.py">Simbad</a>
</h2>

<p>This module allows the user to query the SIMBAD astronomical database from
inside Python or shell commands/scripts. It's four current major functions
<em>Position</em>, <em>Distance</em>, <em>Sptype</em>, and <em>IDList</em> return real variables with
appropriate types ready for use.</p>

<p>As a shell script:</p>

<pre><code>$ Simbad.py

 usage: Simbad.py @Attribute &lt;identifier&gt; [**kwargs]

 The 'Attribute' points to a function within this module and indicates
 what is to be run. Execute 'Simbad.py @Attribute help' for usage details of
 a specific function. Currently available attributes are: `Position`,
 `Distance`, `Sptype` and `IDList`.

 The identifier names can be anything recognized by SIMBAD (e.g., Regulus,
 "alpha leo", "HD 121475", "del cyg", etc ...) if the name is two parts make
 sure to use quotation to enclose it.

 The **kwargs is the conventional reference to Python keyword arguments.
 These should be specific to the 'Attribute' being pointed to.
</code></pre>

<p><a name="PositionLoc"></a></p>

<ul>
<li>
<p><strong>Position</strong> ( <em>identifier</em>, **<em>kwargs</em> ):</p>

<p>Return the right ascension and declination in decimal degrees of
<em>identifier</em> as a pair.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>parse</em></td>
<td>True</td>
<td>parse return file from SIMBAD</td>
</tr>
<tr>
<td><em>full</em></td>
<td>False</td>
<td>return more detailed information</td>
</tr>
</tbody>
</table>

<p><br>
Example:</p>

<div class="highlight highlight-python"><pre>ra, dec <span class="pl-k">=</span> Simbad.Position(<span class="pl-s"><span class="pl-pds">'</span>Sirius<span class="pl-pds">'</span></span>)</pre></div>
</li>
</ul>

<p><a name="DistanceLoc"></a></p>

<ul>
<li>
<p><strong>Distance</strong> ( <em>identifier</em>, **<em>kwargs</em> ):</p>

<p>Return the distance in parsecs to <em>identifier</em>.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>parse</em></td>
<td>True</td>
<td>parse return file from SIMBAD</td>
</tr>
<tr>
<td><em>full</em></td>
<td>False</td>
<td>return more detailed information</td>
</tr>
</tbody>
</table>

<p><br>
Example:</p>

<div class="highlight highlight-python"><pre>distance <span class="pl-k">=</span> Simbad.Distance(<span class="pl-s"><span class="pl-pds">'</span>rigel kent<span class="pl-pds">'</span></span>)</pre></div>
</li>
</ul>

<p><a name="SptypeLoc"></a></p>

<ul>
<li>
<p><strong>Sptype</strong> ( <em>identifier</em>, **<em>kwargs</em> ):</p>

<p>Return the spectral type of <em>identifier</em> as resolved by SIMBAD.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>parse</em></td>
<td>True</td>
<td>parse return file from SIMBAD</td>
</tr>
<tr>
<td><em>full</em></td>
<td>False</td>
<td>return more detailed information</td>
</tr>
</tbody>
</table>

<p><br>
Example:</p>

<div class="highlight highlight-python"><pre><span class="pl-c"># returns 'B8IVn' (HD 87901 is Regulus)</span>
sptype <span class="pl-k">=</span> Simbad.Sptype(<span class="pl-s"><span class="pl-pds">'</span>HD 87901<span class="pl-pds">'</span></span>)</pre></div>
</li>
</ul>

<p><a name="IDListLoc"></a></p>

<ul>
<li>
<p><strong>IDList</strong> ( <em>identifier</em>, **<em>kwargs</em> ):</p>

<p>Return a list of alternate IDs for <em>identifier</em>.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>parse</em></td>
<td>True</td>
<td>parse return file from SIMBAD</td>
</tr>
<tr>
<td><em>full</em></td>
<td>False</td>
<td>return more detailed information</td>
</tr>
</tbody>
</table>

<p><br>
Example:</p>

<div class="highlight highlight-python"><pre>other_names <span class="pl-k">=</span> Simbad.IDList(<span class="pl-s"><span class="pl-pds">'</span>proxima centauri<span class="pl-pds">'</span></span>)</pre></div>
</li>
</ul>

<p><br></p>

<h2>
<a id="correlate" class="anchor" href="#correlate" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="CorrelateLoc"></a><a href="SLiPy/Correlate.py">Correlate</a>
</h2>

<p>Correlation functions for astronomical data.</p>

<p><a name="XCorrLoc"></a></p>

<ul>
<li>
<p><strong>XCorr</strong> ( <em>spectrumA</em>, <em>spectrumB</em>, **<em>kwargs</em> ):</p>

<p>The function returns an integer value representing the best shift within
a <em>lag</em> based on the computed RMS of each configuration.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>lag</em></td>
<td>25</td>
<td>pixel range to shift over</td>
</tr>
</tbody>
</table>
</li>
</ul>

<p><br></p>

<h2>
<a id="telluric" class="anchor" href="#telluric" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="TelluricLoc"></a><a href="SLiPy/Telluric.py">Telluric</a>
</h2>

<p>Removal of atmospheric absorption lines in spectra.</p>

<p><a name="CorrectLoc"></a></p>

<ul>
<li>
<p><strong>Correct</strong> ( <em>spectrum</em>, *<em>calibration</em>, **<em>kwargs</em> ):</p>

<p>Perform a telluric correction on <em>spectrum</em> with one or more
<em>calibration</em> spectra. If more than one calibration spectrum is
provided, the one with the best fit after performing both a
horizontal cross correlation and a vertical amplitude fit is used.
The spectrum and all the calibration spectra must have the same
number of pixels (elements). If a horizontal shift in the calibration
spectra is appropriate, only the corresponding range of the spectrum
is divided out!</p>

<p><strong>Notice</strong> Your spectra must be continuum normalized for this to work!</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>lag</em></td>
<td>25</td>
<td>pixel range to shift over</td>
</tr>
<tr>
<td><em>range</em></td>
<td>(0.5, 2.0, 151)</td>
<td>numpy.linspace for amplitude fitting</td>
</tr>
</tbody>
</table>

<p><img src="Figures/HD192640.png" alt="example"></p>

<p><strong>Figure 1:</strong> The above figure is an example of applying the
<strong>Telluric.Correct()</strong> algorithm to a spectrum. In this case, six spectra of
<em>Regulus</em> from the Elodie archive were used as calibration spectra.</p>
</li>
</ul>

<p><br></p>

<h2>
<a id="velocity" class="anchor" href="#velocity" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="VelocityLoc"></a><a href="SLiPy/Velocity.py">Velocity</a>
</h2>

<p>Radial velocity corrections for 1D spectra.</p>

<p><a name="HelioCorrectLoc"></a></p>

<ul>
<li>
<p><strong>HelioCorrect</strong> ( <em>observatory</em>, *<em>spectra</em>, **<em>kwargs</em> ):</p>

<p>Perform heliocentric velocity corrects on <em>spectra</em> based on
<em>observatory</em> parameters (<em>longitude</em>, <em>latitude</em>, <em>altitude</em>) and the
member attributes, <em>ra</em> (right ascension), <em>dec</em> (declination), and <em>jd</em>
(julian date) from the <em>spectra</em>. These should all have units.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>verbose</em></td>
<td>False</td>
<td>display messages, progress</td>
</tr>
</tbody>
</table>
</li>
</ul>

<p><a name="BaryCorrectLoc"></a></p>

<ul>
<li>
<p><strong>BaryCorrect</strong> ( <em>observatory</em>, *<em>spectra</em>, **<em>kwargs</em> ):</p>

<p>Perform barycentric velocity corrects on <em>spectra</em> based on
<em>observatory</em> parameters (<em>longitude</em>, <em>latitude</em>, <em>altitude</em>) and the
member attributes, <em>ra</em> (right ascension), <em>dec</em> (declination), and <em>jd</em>
(julian date) from the <em>spectra</em>. These should all have units.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>verbose</em></td>
<td>False</td>
<td>display messages, progress</td>
</tr>
</tbody>
</table>
</li>
</ul>

<p><a name="IrafInputLoc"></a></p>

<ul>
<li>
<p><strong>IrafInput</strong> ( *<em>files</em>, **<em>kwargs</em> ):</p>

<p>Build an input file for IRAF's rvcorrect task.</p>

<p><em>files</em> should be a list of FITS file names to build the output table for.
The user can optionally specify a <em>toplevel</em> directory to search for files
under. If <em>outfile</em> is given, write results to the file.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>toplevel</em></td>
<td>None</td>
<td>search <em>toplevel</em> directory for files</td>
</tr>
<tr>
<td><em>pattern</em></td>
<td>'*.fits'</td>
<td>pattern matching under <em>toplevel</em>
</td>
</tr>
<tr>
<td><em>recursive</em></td>
<td>False</td>
<td>search recusively under <em>toplevel</em>
</td>
</tr>
<tr>
<td><em>outfile</em></td>
<td>None</td>
<td>write lines to file named <em>outfile</em>
</td>
</tr>
</tbody>
</table>
</li>
</ul>

<p><br></p>

<h2>
<a id="observatory" class="anchor" href="#observatory" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="ObservatoryLoc"></a><a href="SLiPy/Observatory.py">Observatory</a>
</h2>

<p>Define observatory parameter similar to the IRAF task. All observatories
should follow the following pattern. The user can add as many as they like
to this module. I welcome suggestions.</p>

<p><a name="OHPLoc"></a></p>

<div class="highlight highlight-Python"><pre><span class="pl-k">class</span> <span class="pl-en">OHP</span>(<span class="pl-e">Observatory</span>):
    <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    The Observatoire de Haute-Provence, France.</span>
<span class="pl-s">    <span class="pl-pds">"""</span></span>
    <span class="pl-k">def</span> <span class="pl-en"><span class="pl-c1">__init__</span></span>(<span class="pl-smi">self</span>):
        <span class="pl-v">self</span>.name      <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Observatoire de Haute-Provence<span class="pl-pds">'</span></span>
        <span class="pl-v">self</span>.longitude <span class="pl-k">=</span> <span class="pl-c1">356.28667</span>  <span class="pl-k">*</span> u.degree <span class="pl-c"># West</span>
        <span class="pl-v">self</span>.latitude  <span class="pl-k">=</span> <span class="pl-c1">43.9308334</span> <span class="pl-k">*</span> u.degree <span class="pl-c"># North</span>
        <span class="pl-v">self</span>.altitude  <span class="pl-k">=</span> <span class="pl-c1">650</span>        <span class="pl-k">*</span> u.meter
        <span class="pl-v">self</span>.timezone  <span class="pl-k">=</span> <span class="pl-c1">1</span>          <span class="pl-k">*</span> u.hourangle</pre></div>

<p>There are currently 69 defined observatories:</p>

<table>
<thead>
<tr>
<th>Class ID</th>
<th>Observatory Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>OHP</td>
<td>The Observatoire de Haute-Provence, France.</td>
</tr>
<tr>
<td>KPNO</td>
<td>Kitt Peak National Observatory</td>
</tr>
<tr>
<td>WIYN</td>
<td>WIYN Observatory</td>
</tr>
<tr>
<td>CTIO</td>
<td>Cerro Tololo Interamerican Observatory</td>
</tr>
<tr>
<td>LASILLA</td>
<td>European Southern Observatory: La Silla.</td>
</tr>
<tr>
<td>PARANAL</td>
<td>European Southern Observatory: Paranal</td>
</tr>
<tr>
<td>LICK</td>
<td>Lick Observatory</td>
</tr>
<tr>
<td>MMTO</td>
<td>MMT Observatory</td>
</tr>
<tr>
<td>CFHT</td>
<td>Canada-France-Hawaii Telescope</td>
</tr>
<tr>
<td>LAPALMA</td>
<td>Roque de los Muchachos, La Palma.</td>
</tr>
<tr>
<td>MSO</td>
<td>Mt. Stromlo Observatory</td>
</tr>
<tr>
<td>SSO</td>
<td>Siding Spring Observatory</td>
</tr>
<tr>
<td>AAO</td>
<td>Anglo-Australian Observatory</td>
</tr>
<tr>
<td>MCDONALD</td>
<td>McDonald Observatory</td>
</tr>
<tr>
<td>LCO</td>
<td>Las Campanas Observatory</td>
</tr>
<tr>
<td>MTBIGELOW</td>
<td>Catalina Observatory: 61 inch telescope</td>
</tr>
<tr>
<td>DAO</td>
<td>Dominion Astrophysical Observatory</td>
</tr>
<tr>
<td>SPM</td>
<td>Observatorio Astronomico Nacional, San Pedro Martir.</td>
</tr>
<tr>
<td>TONA</td>
<td>Observatorio Astronomico Nacional, Tonantzintla.</td>
</tr>
<tr>
<td>PALOMAR</td>
<td>The Hale Telescope</td>
</tr>
<tr>
<td>MDM</td>
<td>Michigan-Dartmouth-MIT Observatory</td>
</tr>
<tr>
<td>NOV</td>
<td>National Observatory of Venezuela</td>
</tr>
<tr>
<td>BMO</td>
<td>Black Moshannon Observatory</td>
</tr>
<tr>
<td>BAO</td>
<td>Beijing XingLong Observatory</td>
</tr>
<tr>
<td>KECK</td>
<td>W. M. Keck Observatory</td>
</tr>
<tr>
<td>EKAR</td>
<td>Mt. Ekar 182 cm. Telescope</td>
</tr>
<tr>
<td>APO</td>
<td>Apache Point Observatory</td>
</tr>
<tr>
<td>LOWELL</td>
<td>Lowell Observatory</td>
</tr>
<tr>
<td>VBO</td>
<td>Vainu Bappu Observatory</td>
</tr>
<tr>
<td>IAO</td>
<td>Indian Astronomical Observatory, Hanle</td>
</tr>
<tr>
<td>FLWO</td>
<td>Whipple Observatory</td>
</tr>
<tr>
<td>FLWO1</td>
<td>Whipple Observatory</td>
</tr>
<tr>
<td>ORO</td>
<td>Oak Ridge Observatory</td>
</tr>
<tr>
<td>LNA</td>
<td>Laboratorio Nacional de Astrofisica - Brazil</td>
</tr>
<tr>
<td>SAAO</td>
<td>South African Astronomical Observatory</td>
</tr>
<tr>
<td>CASLEO</td>
<td>Complejo Astronomico El Leoncito, San Juan.</td>
</tr>
<tr>
<td>BOSQUE</td>
<td>Estacion Astrofisica Bosque Alegre, Cordoba.</td>
</tr>
<tr>
<td>ROZHEN</td>
<td>National Astronomical Observatory Rozhen - Bulgaria.</td>
</tr>
<tr>
<td>IRTF</td>
<td>NASA Infrared Telescope Facility</td>
</tr>
<tr>
<td>BGSUO</td>
<td>Bowling Green State Univ Observatory.</td>
</tr>
<tr>
<td>DSAZ</td>
<td>Deutsch-Spanisches Observatorium Calar Alto - Spain.</td>
</tr>
<tr>
<td>CA</td>
<td>Calar Alto Observatory</td>
</tr>
<tr>
<td>HOLI</td>
<td>Observatorium Hoher List (Universitaet Bonn) - Germany.</td>
</tr>
<tr>
<td>LMO</td>
<td>Leander McCormick Observatory</td>
</tr>
<tr>
<td>FMO</td>
<td>Fan Mountain Observatory</td>
</tr>
<tr>
<td>WHITIN</td>
<td>Whitin Observatory,Wellesley College</td>
</tr>
<tr>
<td>OSN</td>
<td>Observatorio de Sierra Nevada</td>
</tr>
<tr>
<td>GEMINI NORTH</td>
<td>Gemini North Observatory</td>
</tr>
<tr>
<td>GEMINI SOUTH</td>
<td>Gemini South Observatory</td>
</tr>
<tr>
<td>LASILLA</td>
<td>European Southern Observatory: La Silla.</td>
</tr>
<tr>
<td>PARANAL</td>
<td>European Southern Observatory: Paranal.</td>
</tr>
<tr>
<td>ESONTT</td>
<td>European Southern Observatory, NTT, La Silla.</td>
</tr>
<tr>
<td>ESO36M</td>
<td>European Southern Observatory, 3.6m Telescope, La Silla.</td>
</tr>
<tr>
<td>ESOVLT</td>
<td>European Southern Observatory, VLT, Paranal.</td>
</tr>
<tr>
<td>SLN</td>
<td>SLN - Catania Astrophysical Observatory.</td>
</tr>
<tr>
<td>EUO</td>
<td>Ege University Observatory</td>
</tr>
<tr>
<td>TNO</td>
<td>Turkiye National Observatory</td>
</tr>
<tr>
<td>TUG</td>
<td>TUBITAK National Observatory, Turkey.</td>
</tr>
<tr>
<td>MGO</td>
<td>Mount Graham Observatory</td>
</tr>
<tr>
<td>ARIES</td>
<td>Aryabhatta Research Institute of Observational Sciences.</td>
</tr>
<tr>
<td>OALP</td>
<td>Observatorio Astronomico de La Plata</td>
</tr>
<tr>
<td>OLIN</td>
<td>Connecticut College - Olin Observatory</td>
</tr>
<tr>
<td>BOYDEN</td>
<td>Boyden Observatory</td>
</tr>
<tr>
<td>LULIN</td>
<td>Lulin Observatory</td>
</tr>
<tr>
<td>SOAR</td>
<td>Southern Astrophysical Research Telescope.</td>
</tr>
<tr>
<td>BAKER</td>
<td>Baker Observatory</td>
</tr>
<tr>
<td>HET</td>
<td>McDonald Observatory - Hobby-Eberly Telescope.</td>
</tr>
<tr>
<td>JCDO</td>
<td>Jack C. Davis Observatory, Western Nevada College</td>
</tr>
<tr>
<td>LNO</td>
<td>Langkawi National Observatory</td>
</tr>
</tbody>
</table>

<p><br></p>

<h2>
<a id="plot" class="anchor" href="#plot" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="PlotLoc"></a><a href="SLiPy/Plot.py">Plot</a>
</h2>

<p>Convenient wrappers to matplotlib for plotting spectra. A <em>SPlot</em> simply
creates a handle to remember figure attributes, to quickly go from looking
at one spectra to another. One can also <em>overlay</em> spectra.</p>

<p><a name="SPlotLoc"></a></p>

<ul>
<li>
<p>class <strong>SPlot</strong> ( <em>spectrum</em>, **<em>kwargs</em> ):</p>

<p>Spectrum Plot - Create figure of <em>spectrum</em>.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>marker</em></td>
<td>'b-'</td>
<td>marker for data</td>
</tr>
<tr>
<td><em>label</em></td>
<td>'spectrum'</td>
<td>name of object</td>
</tr>
<tr>
<td><em>usetex</em></td>
<td>False</td>
<td>render with pdflatex</td>
</tr>
</tbody>
</table>

<p><br>
The following member functions call pyplot equivalent:<br>
<strong>xlim</strong>, <strong>ylim</strong>, <strong>xlabel</strong>, <strong>ylabel</strong>, <strong>title</strong>, <strong>legend</strong>,
<strong>text</strong>, <strong>grid</strong>, <strong>close</strong>.</p>

<p>Here, when these function are called, the arguments are passed to
matplotlib; however, these calls are remembered. So when you go to <em>draw</em>
the figure again, you are back where you left off.</p>

<ul>
<li>
<p><em>draw</em>( ):</p>

<p>Rebuild and render the figure.</p>
</li>
<li>
<p><em>refresh</em>( ):</p>

<p>Re-render (refresh) the figure, without clearing the axis.</p>
</li>
<li>
<p><em>txtclear</em>( ):</p>

<p>Clear all the calls to <em>text</em>( ) from the figure.</p>
</li>
<li>
<p><em>xoffset</em>( <em>value</em> ):</p>

<p>Switch either on or off (<em>value</em> = True | False) the horizontal offset.</p>
</li>
<li>
<p><em>yoffset</em>( <em>value</em> ):</p>

<p>Switch either on or off (<em>value</em> = True | False) the vertical offset.</p>
</li>
<li>
<p><em>overlay</em>( *<em>splots</em> ):</p>

<p>Given one or more <em>splots</em>, <em>overlay</em> the figures.</p>
</li>
<li>
<p><em>markers</em>( *<em>args</em> ):</p>

<p>Reassign the values for the <code>marker</code>s in the figure. The number
of arguments must equal the number of spectra in the figure. This
starts out as one, but will increase for ever call to SPlot.overlay().</p>
</li>
<li>
<p><em>restore</em>( ):</p>

<p>Restore the figure to only the original spectrum.</p>
</li>
<li>
<p><em>save</em>( <em>filename</em> ):</p>

<p>Save the figure to a file called <em>filename</em>. The file format is derived
from the extention of <em>filename</em>.</p>
</li>
</ul>
</li>
</ul>

<p><a name="IterateLoc"></a></p>

<ul>
<li>
<p><strong>Iterate</strong>( *<em>splots</em>, **<em>kwargs</em> ):</p>

<p>Iterate thru <em>splots</em> to inspect data, the user marks spectra of
interest. The function returns a list of <em>keepers</em>.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>keep</em></td>
<td>'name'</td>
<td>alternative is 'plot'</td>
</tr>
</tbody>
</table>

<p><br>
<strong>Example:</strong></p>

<div class="highlight highlight-python"><pre><span class="pl-k">from</span> slipy <span class="pl-k">import</span> Fits, Plot

fpath <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>?<span class="pl-pds">'</span></span> <span class="pl-c"># toplevel directory name where your FITS files are</span>
files <span class="pl-k">=</span> Fits.Find(fpath)

spectra <span class="pl-k">=</span> Fits.GetData( <span class="pl-k">*</span>files )

figure <span class="pl-k">=</span> [

    Plot.SPlot( spectrum, <span class="pl-smi">label</span><span class="pl-k">=</span>Fits.Header(fname, <span class="pl-s"><span class="pl-pds">'</span>object<span class="pl-pds">'</span></span>) )
    <span class="pl-k">for</span> spectrum, fname <span class="pl-k">in</span> <span class="pl-c1">zip</span>(spectra, files)
]

keepers <span class="pl-k">=</span> Plot.Iterate( <span class="pl-k">*</span>figure )
<span class="pl-c"># enter either 'y', 'n', or 'x' as prompted by the terminal</span></pre></div>
</li>
</ul>

<p><br></p>

<h2>
<a id="profile" class="anchor" href="#profile" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="ProfileLoc"></a><a href="SLiPy/Profile.py">Profile</a>
</h2>

<p>Profile fitting tasks for spectra.</p>

<p><a name="SelectLoc"></a></p>

<ul>
<li>
<p><strong>Select</strong> ( <em>splot</em> ):</p>

<p>Select points from the <em>splot</em>. This should be of type SPlot 
(or it can optionally be a Spectrum type, for which a SPlot will be
created). The splot will be rendered and the user clicks on the 
figure. When finished, return to the terminal prompt. A dictionary is
returned with two entries, <em>wave</em> and <em>data</em>, representing the x-y
locations selected by the user. This can always be retrieved later by
accessing the module member <em>Profile.selected</em>.</p>

<p>While the user makes selections, temporary markers appear on the figure
indicating the data point that was just selected. If a mark does not 
appear, try moving the curser slightly and trying again. Even if the line
goes through that point, there might not actually be data there.</p>
</li>
</ul>

<p><a name="FitLoc"></a></p>

<ul>
<li>
<p><strong>Fit</strong> ( <em>splot</em>, <em>function</em> = InvertedLorentzian, <em>params</em> = None)</p>

<p>Given a <em>splot</em> of type Plot.SPlot, the user selects four points on the 
spectrum and a parameterized function is fit (an inverted Lorentzian by
default). Optionally, <em>splot</em> can be of type spectrum and a basic SPlot
will be created for you. If the user gives an alternative <em>function</em>, 
<em>params</em> (parameters) must be provided. <em>params</em> is to be the first guess, 
<em>p0</em> given to scipy...curve_fit; the user can provide them expicitely, 
or in the form of functions with the templates <code>f(x, y)</code>
where <em>x</em> and <em>y</em> are the <em>wave</em> and <em>data</em> arrays (respectively) extracted
between the two inner points selected by the user.</p>

<p><em>InvertedLorentian</em> is defined in SLiPy.Algorithms.Functions. The user does
not need to provide <em>params</em> for the default behavior.</p>

<p><strong>Example:</strong></p>

<div class="highlight highlight-python"><pre><span class="pl-c"># In this example I use an alternative function simply as an illustration.</span>
<span class="pl-c"># I show the download, calibration, and fitting procedure involved ...</span>

<span class="pl-k">from</span> slipy <span class="pl-k">import</span> Fits, Simbad, Plot, Velocity, Telluric, Profile
<span class="pl-k">from</span> slipy <span class="pl-k">import</span> Spectrum, Observatory, SlipyError, Units <span class="pl-k">as</span> u
<span class="pl-k">from</span> slipy.Data <span class="pl-k">import</span> Elodie

<span class="pl-c"># See the Data package for more information about this section</span>
archive <span class="pl-k">=</span> Elodie.Archive()

<span class="pl-c"># the one with highest S/N</span>
sci_file <span class="pl-k">=</span> archive.files[<span class="pl-s"><span class="pl-pds">'</span>HD332329<span class="pl-pds">'</span></span>]

<span class="pl-c"># all files are in `data` member, first column is the file name </span>
cal_files <span class="pl-k">=</span> [ entry[<span class="pl-c1">0</span>] <span class="pl-k">for</span> entry <span class="pl-k">in</span> archive.data[<span class="pl-s"><span class="pl-pds">'</span>HD087901A<span class="pl-pds">'</span></span>] ]

Elodie.Download(
        sci_file,                      <span class="pl-c"># file name to download</span>
        <span class="pl-smi">resample</span> <span class="pl-k">=</span> (<span class="pl-c1">5850</span>, <span class="pl-c1">5950</span>, <span class="pl-c1">0.01</span>), <span class="pl-c"># pipeline command</span>
        <span class="pl-smi">outpath</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Science-Files<span class="pl-pds">'</span></span>      <span class="pl-c"># put under this directory</span>
    )

Elodie.Download(
        <span class="pl-k">*</span>cal_files,                    <span class="pl-c"># HD087901A is Regulus</span>
        <span class="pl-smi">resample</span> <span class="pl-k">=</span> (<span class="pl-c1">5850</span>, <span class="pl-c1">5950</span>, <span class="pl-c1">0.01</span>), <span class="pl-c"># pipeline command</span>
        <span class="pl-smi">outpath</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Calibration-Files<span class="pl-pds">'</span></span>  <span class="pl-c"># put under this directory</span>
    )

sci_file  <span class="pl-k">=</span> Fits.Find(<span class="pl-s"><span class="pl-pds">'</span>Science-Files<span class="pl-pds">'</span></span>)[<span class="pl-c1">0</span>]  <span class="pl-c"># one file</span>
cal_files <span class="pl-k">=</span> Fits.Find(<span class="pl-s"><span class="pl-pds">'</span>Calibration-Files<span class="pl-pds">'</span></span>) <span class="pl-c"># six files (list)</span>

spectrum <span class="pl-k">=</span> Spectrum(sci_file)       <span class="pl-c"># create spectrum object</span>
regulus  <span class="pl-k">=</span> Fits.GetData(<span class="pl-k">*</span>cal_files) <span class="pl-c"># return list of spectrum objects</span>

<span class="pl-c"># remove absorption due to Earth's atmosphere</span>
Telluric.Correct(spectrum, <span class="pl-k">*</span>regulus)

<span class="pl-c"># attach `ra`, `dec` and `jd` to spectrum for HelioCorrect()</span>
<span class="pl-c"># Simbad returns values in units of decimal degrees</span>
ra, dec <span class="pl-k">=</span> Simbad.Position(<span class="pl-s"><span class="pl-pds">'</span>HD332329<span class="pl-pds">'</span></span>)

<span class="pl-c"># elements returned from Fits.Header() are unitless. Here we take</span>
<span class="pl-c"># the MJD at beginning of exposure and solve for JD at middle of exposure</span>
MJD     <span class="pl-k">=</span> Fits.Header(sci_file, <span class="pl-s"><span class="pl-pds">'</span>MJD-OBS<span class="pl-pds">'</span></span>)
EXPTIME <span class="pl-k">=</span> Fits.Header(sci_file, <span class="pl-s"><span class="pl-pds">'</span>EXPTIME<span class="pl-pds">'</span></span>)
JD      <span class="pl-k">=</span> MJD <span class="pl-k">+</span> <span class="pl-c1">2400000.5</span> <span class="pl-k">+</span> <span class="pl-c1">0.5</span> <span class="pl-k">*</span> EXPTIME <span class="pl-k">/</span> <span class="pl-c1">86400</span>

<span class="pl-c"># attach to spectrum object as members</span>
spectrum.ra  <span class="pl-k">=</span> ra
spectrum.dec <span class="pl-k">=</span> dec
spectrum.jd  <span class="pl-k">=</span> JD <span class="pl-k">*</span> u.day

<span class="pl-c"># Elodie is at the Observatoire de Haute-Provence, France (OHP).</span>
Velocity.HelioCorrect( Observatory.OHP(), spectrum )

<span class="pl-c"># create figure</span>
fig <span class="pl-k">=</span> Plot.SPlot(spectrum, <span class="pl-smi">label</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>HD332329<span class="pl-pds">'</span></span>, <span class="pl-smi">marker</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>k-<span class="pl-pds">'</span></span>)
fig.xlabel(<span class="pl-s"><span class="pl-pds">'</span>Wavelength (Angstrom)<span class="pl-pds">'</span></span>, <span class="pl-smi">labelpad</span><span class="pl-k">=</span><span class="pl-c1">20</span>)
fig.ylabel(<span class="pl-s"><span class="pl-pds">'</span>Normalized Flux<span class="pl-pds">'</span></span>, <span class="pl-smi">labelpad</span><span class="pl-k">=</span><span class="pl-c1">20</span>)
fig.xlim(<span class="pl-c1">5885</span>, <span class="pl-c1">5905</span>)
fig.legend(<span class="pl-smi">frameon</span><span class="pl-k">=</span><span class="pl-c1">False</span>)

<span class="pl-c"># Now we need to define some parameter functions to pass to Profile.Fit()</span>
<span class="pl-c"># with our user function</span>
<span class="pl-k">from</span> slipy.Algorithms.Functions <span class="pl-k">import</span> InvertedGaussian

<span class="pl-c"># best guess for amplitude of gaussian</span>
<span class="pl-k">def</span> <span class="pl-en">A</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
    <span class="pl-k">return</span> <span class="pl-c1">1</span> <span class="pl-k">-</span> y.min().value

<span class="pl-c"># best guess for mean of gaussian</span>
<span class="pl-k">def</span> <span class="pl-en">mu</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
    <span class="pl-k">return</span> x[ y.argmin() ].value

<span class="pl-c"># best guess for standard deviation of gaussian</span>
<span class="pl-k">def</span> <span class="pl-en">sigma</span>(<span class="pl-smi">x</span>, <span class="pl-smi">y</span>):
    <span class="pl-k">return</span> y.std().value

<span class="pl-c"># call the Profile.Fit() function with our user defined parameterization</span>
line <span class="pl-k">=</span> Profile.Fit(fig, <span class="pl-smi">function</span><span class="pl-k">=</span>InvertedGaussian, <span class="pl-smi">params</span><span class="pl-k">=</span>[A, mu, sigma])

<span class="pl-c"># Please select four points identifying the spectral line.</span>
<span class="pl-c"># Outer points mark the domain of the line.</span>
<span class="pl-c"># Inner points mark the sample of the line to fit.</span>
<span class="pl-c"># Press &lt;Return&gt; after making your selections ...</span>

<span class="pl-c"># now `line` is a Spectrum object generated by evaluating the </span>
<span class="pl-c"># `InvertedGaussian` function on the larger domain selected by the</span>
<span class="pl-c"># user with coefficients optimized using Profile.Fit().</span>
<span class="pl-c"># You might use it to deblend this inner line with the overlapping ones.</span>

<span class="pl-c"># save the figure ...</span>
fig.tight_layout()
fig.xoffset(<span class="pl-c1">False</span>)
fig.refresh()
fig.save(<span class="pl-s"><span class="pl-pds">'</span>HD332329.png<span class="pl-pds">'</span></span>)</pre></div>

<p><img src="Figures/Profile-Fit.png" alt="example"></p>

<p><strong>Figure 2:</strong> The above figure was generated by running the above code 
snippet.</p>
</li>
</ul>

<p><a name="ExtractLoc"></a></p>

<ul>
<li>
<p><strong>Extract</strong> ( <em>splot</em>, <em>kernel</em> = Gaussian, **<em>kwargs</em>):</p>

<p>Select locations in the <em>splot</em> figure, expected to be of type SPlot.
Exactly four points should be selected. These are used to extract a 
line profile from the spectrum plotted in the splot figure. The inner
section is used for the line, and the outer intervals are used to model
the continuum; these, respectively, are both returned as Spectrum objects.
The gap is jumped using 1D interpolation (scipy...interp1d). In order
to get a smooth continuum and error estimates, this function uses
non-parametric kernel regression (a.k.a. kernel smoothing) to fit a
curve through the data marked as continuum. Be default, the kernel
function is the Gaussian. The user can actually use a different, user
defined kernel function, but it's template must match that of
SLiPy.Algorithms.Functions.Gaussian. See the SLiPy.Algorithms.KernelFit
module to better understand how this happens. The <em>bandwidth</em> is actually
the standard deviation in the Gaussian. It is a length scale that defines
how influencial data is at a particular distance. The default bandwidth
will almost definitely be too large (resulting in a largely flat result
at the average of the data points). As the bandwidth decreases to smaller
than the resolution of the data, you will essentially being performing
linear interpolation (no smoothing). You want to choose a length that is
larger than the small scale variation in the noise, but smaller than the 
larger scale variation in the overall continuum level.</p>

<p>The <em>rms</em> can optionally be computed between the continuum data and the 
curve fit to it. This rms value is used to scale the error profile 
that is returned for the line extracted. Explicitely, the error for a
line extraction is <code>error_spectrum = continuum_rms * I_0 / I</code> where
<em>I</em> is the line data and <em>I_0</em> is the interpolated continuum over the 
gap.</p>

<p>From the documentation of scipy.interpolate...interp1d: <em>kind</em> specifies the 
kind of interpolation as a string ('linear', 'nearest', 'zero', 'slinear', 
'quadratic', 'cubic') where 'slinear', 'quadratic' and 'cubic' refer to a 
spline interpolation of first, second,  or third order respectively;  or as 
an integer specifying the order of the spline interpolator to use.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>kind</em></td>
<td>'cubic'</td>
<td>given to scipy...interp1d for continuum</td>
</tr>
<tr>
<td><em>bandwidth</em></td>
<td>0.1 * u.nm</td>
<td>for kernel, user should provide this!</td>
</tr>
<tr>
<td><em>rms</em></td>
<td>False</td>
<td>return an error estimate for the line</td>
</tr>
</tbody>
</table>

<p><br>
<strong>Example:</strong></p>

<div class="highlight highlight-python"><pre><span class="pl-c"># drawing from the previous example, but using HD200723 instead.</span>

line, continuum, rms <span class="pl-k">=</span> Profile.Extract(fig, <span class="pl-smi">bandwidth</span><span class="pl-k">=</span>u.Angstrom<span class="pl-k">/</span><span class="pl-c1">15</span>, <span class="pl-smi">rms</span><span class="pl-k">=</span><span class="pl-c1">True</span>)

<span class="pl-c"># Please select four points identifying the spectral line.</span>
<span class="pl-c"># Outer intervals sample the continuum.</span>
<span class="pl-c"># Center interval contains the line.</span>
<span class="pl-c"># Press &lt;Return&gt; after making your selections ...</span></pre></div>

<p><img src="Figures/Profile-Extract.png" alt="example"></p>

<p><strong>Figure 3:</strong> The above figure was generated by running the above code 
snippet.</p>
</li>
</ul>

<p><br></p>

<h2>
<a id="montage" class="anchor" href="#montage" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="MontageLoc"></a><a href="SLiPy/Montage.py">Montage</a>
</h2>

<p><a href="http://montage.ipac.caltech.edu/">Montage</a> is a very powerful suite of C code
for creating image mosaics. This module is a wrapper to automate not only the
process for small projects, but to segment large fields into a grid and
mosaic each <em>site</em> before combining them into a <em>master</em> mosaic.</p>

<p><a name="MSolveGridLoc"></a></p>

<ul>
<li>
<p><strong>SolveGrid</strong> ( <em>sides</em>, <em>grid</em> ):</p>

<p>Helper function for the Field and SubField classes. Both <em>sides</em> and <em>grid</em>
need to be array-like and of length two. <em>sides</em> is the side length of the
field in decimal degrees in right ascension and declination respectively.
<em>grid</em> specifies the subdivision along these axis (e.g., (2,2) says 2x2).</p>

<p>The user should mindful of their choices. If the side lengths cannot be
subdivided into well-behaved (rational) segments, higher decimal places
will be lost in the SubField.ArchiveList() task resulting in small
gaps in the mosaic.</p>
</li>
</ul>

<p><a name="MMosaicLoc"></a></p>

<ul>
<li>
<p><strong>Mosaic</strong> ( <em>resolution</em>, *<em>folders</em>, **<em>kwargs</em> ):</p>

<p>Conduct standard build procedures for all <em>folders</em>, similar to the
<a href="http://montage.ipac.caltech.edu/docs/m101tutorial.html">m101 example</a>.
<em>resolution</em> is the number of pixels per degree for the output image.
Note: <em>folders</em> should be absolute paths. Further, below each of these
directories, there should already exist the standard folder structure</p>

<pre><code>folder/
  |--images/
  |    |-- &lt;location of raw FITS images&gt;
  |
  |--projected/
  |--differences/
  |--corrected/
  |--final/
</code></pre>

<p><br>
The mosaic will be deposited at <em>final/mosaic.fits</em>.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>verbose</em></td>
<td>True</td>
<td>display messages, progress</td>
</tr>
<tr>
<td><em>bkmodel</em></td>
<td>True</td>
<td>model and correct for background effects</td>
</tr>
</tbody>
</table>
</li>
</ul>

<p><a name="MSubFieldLoc"></a></p>

<ul>
<li>
<p>class <strong>SubField</strong> ( <em>center</em>, <em>sides</em>, <em>grid</em>, **<em>kwargs</em> ):</p>

<p>Create a grid of <em>sites</em> each of which will be mosaiced separately and
then combined. Each of <em>center</em>, <em>sides</em>, and <em>grid</em> should be array-like
and of length two. <em>center</em> should be the very center location for the
mosaic in right ascension and declination (both in decimal degrees),
respectively. <em>sides</em> needs to give the side lengths of the desired
mosaic in decimal degrees (width-RA, height-DEC). <em>grid</em> should be the
grid division for the field (e.g., (2, 2) means 2x2 grid).</p>

<p>There will be a directory created for each <em>site</em> and also another <em>master</em>
directory. The final resulting mosaic will be deposited at
<em>final/mosaic.fits</em> here.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>verbose</em></td>
<td>True</td>
<td>display messages, progress</td>
</tr>
<tr>
<td><em>survey</em></td>
<td>'DSS'</td>
<td>DSS, SDSS, 2MASS</td>
</tr>
<tr>
<td><em>band</em></td>
<td>'DSS2B'</td>
<td>filter for <em>survey</em>, see <em>bands</em> dict</td>
</tr>
<tr>
<td><em>pad</em></td>
<td>0.0</td>
<td>amount to add (degrees) around <em>sites</em>
</td>
</tr>
</tbody>
</table>

<p><br>
The available filter band for each survey are as follows</p>

<table>
<thead>
<tr>
<th>Survey</th>
<th>Bands</th>
</tr>
</thead>
<tbody>
<tr>
<td>'2MASS'</td>
<td>'J', 'H', 'K'</td>
</tr>
<tr>
<td>'SDSS'</td>
<td>'U', 'G', 'R', 'I', 'Z'</td>
</tr>
<tr>
<td>'DSS'</td>
<td>'DSS1B', 'DSS1R', 'DSS2B', 'DSS2R', 'DSS2IR', 'Quick-V'</td>
</tr>
</tbody>
</table>

<p><br>
The user should execute the following available methods in this order:</p>

<ul>
<li>
<p><em>ArchiveList</em> ( **<em>kwargs</em> ):</p>

<p>Run the <code>mArchiveList</code> command on the <em>site</em> grid. The only keyword
argument is <em>verbose</em> which defaults to True.</p>
</li>
<li>
<p><em>ArchiveExec</em> ( **<em>kwargs</em> ):</p>

<p>Run <code>mArchiveExec</code> on each <em>site</em> in the SubField. The only keyword
argument is <em>verbose</em> which defaults to True.</p>
</li>
<li>
<p><em>Build</em> ( <em>resolution</em>, **<em>kwargs</em>):</p>

<p>Run the build process for the <em>sites</em> in this SubField. See the
Montage.Mosaic() function documentation.</p>
</li>
<li>
<p><em>Collect</em> ( **<em>kwargs</em> ):</p>

<p>Collect the mosaics from all <em>site</em> locations into a master <em>images</em>
folder. The only keyword argument is <em>verbose</em> which defaults to True.</p>
</li>
<li>
<p><em>Merge</em> ( <em>resolution</em>, **<em>kwargs</em> ):</p>

<p>Merge all <em>site</em> mosaics into a single master SubField mosaic. We are
now calling Montage.Mosaic() on each <em>site</em>.</p>
</li>
</ul>

<p><br>
<strong>Example:</strong></p>

<div class="highlight highlight-python"><pre><span class="pl-k">from</span> slipy <span class="pl-k">import</span> Montage, Simbad

mosaic <span class="pl-k">=</span> Montage.SubField(

    Simbad.Position(<span class="pl-s"><span class="pl-pds">'</span>Pleiades<span class="pl-pds">'</span></span>), <span class="pl-c"># center of the Pleiades</span>
    (<span class="pl-c1">4</span>, <span class="pl-c1">4</span>),                      <span class="pl-c"># side lengths of mosaic</span>
    (<span class="pl-c1">2</span>, <span class="pl-c1">2</span>)                       <span class="pl-c"># grid pattern creates 2x2 degree `sites`</span>
)

mosaic.ArchiveList()
mosaic.ArchiveExec()
mosaic.Build()
mosaic.Collect()
mosaic.Merge()

<span class="pl-c"># If you have APLpy</span>
<span class="pl-k">import</span> aplpy

fig <span class="pl-k">=</span> aplpy.FITSFigure(<span class="pl-s"><span class="pl-pds">'</span>master/final/mosaic.fits<span class="pl-pds">'</span></span>)
fig.show_grayscale()
</pre></div>
</li>
</ul>

<p><a name="MFieldLoc"></a></p>

<ul>
<li>
<p>class <strong>Field</strong> (<em>center</em>, <em>sides</em>, <em>grid</em>, <em>subgrid</em>, **<em>kwargs</em> ):</p>

<p>Large image mosaic manager for Montage. This class (in terms of its
usage) is the same as the <em>SubField</em> class, except that here we managing
the subfields. So all the member functions are the same name and purpose,
but instead act to call that same function on each subfield. Here, all
the constructor arguments are as before, with the additions of <em>subgrid</em>
which is also to be array-like of length two. <em>grid</em> will be the first
level division to find the centers and side lengths of all the subfields
and <em>subgrid</em> will be the further sub-division passed down to the daughter
subfields.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>verbose</em></td>
<td>True</td>
<td>display messages, progress</td>
</tr>
<tr>
<td><em>survey</em></td>
<td>'DSS'</td>
<td>DSS, SDSS, 2MASS</td>
</tr>
<tr>
<td><em>band</em></td>
<td>'DSS2B'</td>
<td>filter for <em>survey</em>, see <em>bands</em> dict</td>
</tr>
<tr>
<td><em>pad</em></td>
<td>0.0</td>
<td>amount to add (degrees) around <em>sites</em>
</td>
</tr>
</tbody>
</table>

<p><br>
The available filter band for each survey are as follows</p>

<table>
<thead>
<tr>
<th>Survey</th>
<th>Bands</th>
</tr>
</thead>
<tbody>
<tr>
<td>'2MASS'</td>
<td>'J', 'H', 'K'</td>
</tr>
<tr>
<td>'SDSS'</td>
<td>'U', 'G', 'R', 'I', 'Z'</td>
</tr>
<tr>
<td>'DSS'</td>
<td>'DSS1B', 'DSS1R', 'DSS2B', 'DSS2R', 'DSS2IR', 'Quick-V'</td>
</tr>
</tbody>
</table>

<p><br>
All the member functions are the same name as in <em>SubField</em>, but now with
the addition of a final step:</p>

<ul>
<li>
<p><em>Finalize</em> ( <em>resolution</em>, **<em>kwargs</em> ):</p>

<p>Collect all SubField/master mosaics into a single folder and
run Mosaic() on them for a single final image.</p>
</li>
</ul>
</li>
</ul>

<p><br></p>

<h2>
<a id="elodie" class="anchor" href="#elodie" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a name="ElodieLoc"></a><a href="Data/Elodie.py">Elodie</a>
</h2>

<p>Methods for data retrieval from the Elodie Archive.</p>

<p><a name="EArchiveLoc"></a></p>

<ul>
<li>
<p>class <strong>Archive</strong> ( **<em>kwargs</em> ):</p>

<p>Import and parse ascii catalog of Elodie archive files. The complete
archive is stored in the member dictionary, <em>data</em>. It's organized
by unique target names. Each target has a list of pairs consisting of the
name of the file and the signal to noise for that spectrum. The reduced
archive by default contains only <em>HD</em>, <em>BD</em>, <em>HR</em>, <em>GC</em>, and <em>GJ</em> objects,
choosing the file pertaining to the spectra with the highest signal-to-noise
ratio available.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>infile</em></td>
<td>archives/elodie.csv</td>
<td>path to input file</td>
</tr>
<tr>
<td><em>catalogs</em></td>
<td>['HD','BD','HR','GC','GJ']</td>
<td>catalogs to keep</td>
</tr>
</tbody>
</table>

<p><br>
<strong>Example:</strong></p>

<div class="highlight highlight-python"><pre><span class="pl-k">from</span> slipy.Data <span class="pl-k">import</span> Elodie

archive <span class="pl-k">=</span> Elodie.Archive()

<span class="pl-s"><span class="pl-pds">'</span>HD187642<span class="pl-pds">'</span></span> <span class="pl-k">in</span> archive.files <span class="pl-c"># returns True (Altair)</span>
<span class="pl-s"><span class="pl-pds">'</span>HD045348<span class="pl-pds">'</span></span> <span class="pl-k">in</span> archive.files <span class="pl-c"># returns False (Canopus)</span></pre></div>
</li>
</ul>

<p><a name="EScriptLoc"></a></p>

<ul>
<li>
<p><strong>Script</strong> ( <em>filename</em>, <em>pipeline</em> = '' ):</p>

<p>Construct url script for Elodie archive given <em>filename</em> and optionally
<em>pipeline</em> instructions (e.g., '&amp;z=wrs|fca[1,nor]').</p>
</li>
</ul>

<p><a name="EDownloadLoc"></a></p>

<ul>
<li>
<p><strong>Download</strong> ( *<em>files</em>, **<em>kwargs</em> ):</p>

<p>Download <em>files</em> from Elodie archive via url scripts. The spectra can be
further reduced via Elodie's pipeline with the following options.</p>

<table>
<thead>
<tr>
<th>Options</th>
<th>Defaults</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>verbose</em></td>
<td>True</td>
<td>display messages, progress</td>
</tr>
<tr>
<td><em>resample</em></td>
<td>(min, max, res)</td>
<td>resample spectra (no default)</td>
</tr>
<tr>
<td><em>normalize</em></td>
<td>True</td>
<td>continuum normalization</td>
</tr>
<tr>
<td><em>outpath</em></td>
<td>'./'</td>
<td>directory for downloaded <em>files</em>
</td>
</tr>
<tr>
<td><em>names</em></td>
<td>[]</td>
<td>alternative output names for <em>files</em>
</td>
</tr>
</tbody>
</table>

<p><br>
<strong>Example:</strong></p>

<div class="highlight highlight-python"><pre><span class="pl-c"># continuing from the previous example ...</span>

<span class="pl-c"># all files in the archive for Altair (file name is first element in pair)</span>
files <span class="pl-k">=</span> [ entry[<span class="pl-c1">0</span>] <span class="pl-k">for</span> entry <span class="pl-k">in</span> archive.data[<span class="pl-s"><span class="pl-pds">'</span>HD187642<span class="pl-pds">'</span></span>] ]

<span class="pl-c"># download files to current directory, resample spectrum to wavelengths</span>
<span class="pl-c"># between 5850 and 5950 with a resolution of 0.01 Angstroms per pixel</span>
Elodie.Download( <span class="pl-k">*</span>files, <span class="pl-smi">resample</span><span class="pl-k">=</span>(<span class="pl-c1">5850</span>, <span class="pl-c1">5950</span>, <span class="pl-c1">0.01</span>) )</pre></div>
</li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/gLENTNER/SLiPy">SLiPy</a> is maintained by <a href="https://github.com/gLENTNER">gLENTNER</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
        <span class="site-footer-credits"><br><br><b>Notice: </b> The source for this page has been modified by Geoffrey Lentner.</span>
		
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-58405300-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>

